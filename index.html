
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CAVE OF ECHOES</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1c1f33 0, #050509 45%, #000 100%);
      color: #f5f5f5;
    }

    canvas {
      display: block;
    }

    /* Overlay UI */
    .ui-root {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
      color: #f7f7ff;
    }

    .ui-safe {
      position: absolute;
      inset: 0;
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      pointer-events: none;
    }

    .ui-top {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      align-items: flex-start;
      pointer-events: none;
    }

    .brand-block {
      pointer-events: auto;
      text-shadow: 0 0 18px rgba(0, 0, 0, 0.9);
    }

    .brand-kicker {
      letter-spacing: 0.28em;
      font-size: 10px;
      text-transform: uppercase;
      color: #6366f1;
      margin-bottom: 4px;
    }

    .brand-title {
      font-size: clamp(26px, 3vw, 32px);
      line-height: 1.02;
      font-weight: 800;
    }

    .brand-title span {
      display: block;
    }

    .brand-sub {
      margin-top: 6px;
      max-width: 360px;
      font-size: 12px;
      color: #d1d5db;
    }

    .brand-sub strong {
      color: #f97316;
      font-weight: 600;
    }

    .meta-block {
      pointer-events: auto;
      text-align: right;
      text-shadow: 0 0 18px rgba(0, 0, 0, 0.9);
    }

    .meta-line {
      font-size: 11px;
      color: #e5e7eb;
      margin-bottom: 2px;
      opacity: 0.9;
    }

    .meta-key {
      text-transform: uppercase;
      letter-spacing: 0.22em;
      font-size: 9px;
      color: #9ca3af;
    }

    .pill-row {
      margin-top: 6px;
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: flex-end;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.25), rgba(15, 23, 42, 0.9));
      font-size: 10px;
      color: #e5e7eb;
      backdrop-filter: blur(8px);
    }

    .pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: radial-gradient(circle, #4ade80, #16a34a);
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.9);
    }

    .pill.bad {
      border-color: rgba(239, 68, 68, 0.7);
      background: radial-gradient(circle at top left, rgba(248, 113, 113, 0.3), rgba(15, 23, 42, 0.95));
      color: #fecaca;
    }

    .pill.bad .pill-dot {
      background: radial-gradient(circle, #fecaca, #b91c1c);
      box-shadow: 0 0 12px rgba(248, 113, 113, 0.95);
    }

    /* Bottom HUD */
    .ui-bottom {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 10px;
      font-size: 11px;
      color: #e5e7eb;
      pointer-events: none;
      text-shadow: 0 0 18px rgba(0, 0, 0, 0.9);
    }

    .hint {
      pointer-events: auto;
      max-width: min(80vw, 320px);
      line-height: 1.4;
      color: #cbd5f5;
    }

    .hint-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .hint-main {
      font-size: 11px;
    }

    .hint-main span {
      color: #f97316;
      font-weight: 600;
    }

    .hud {
      pointer-events: auto;
      display: grid;
      grid-auto-flow: column;
      gap: 10px;
      justify-content: flex-end;
      align-items: flex-end;
    }

    .hud-card {
      padding: 6px 10px;
      border-radius: 11px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.92), rgba(3, 7, 18, 0.96));
      backdrop-filter: blur(6px);
      min-width: 90px;
      text-align: right;
      box-shadow: 0 16px 35px rgba(0, 0, 0, 0.85);
    }

    .hud-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #6b7280;
      margin-bottom: 2px;
    }

    .hud-value {
      font-size: 14px;
      font-weight: 600;
      color: #e5e7eb;
    }

    .hud-sub {
      font-size: 9px;
      color: #9ca3af;
      margin-top: 1px;
    }

    .hud-card.bad .hud-value {
      color: #f97316;
    }

    /* Center crosshair */
    .crosshair {
      position: fixed;
      inset: 0;
      margin: auto;
      width: 18px;
      height: 18px;
      pointer-events: none;
      z-index: 5;
      opacity: 0.85;
    }

    .crosshair::before,
    .crosshair::after {
      content: "";
      position: absolute;
      inset: 50%;
      transform: translate(-50%, -50%);
      border-radius: 999px;
    }

    .crosshair::before {
      width: 3px;
      height: 14px;
      background: linear-gradient(to bottom, rgba(249, 115, 22, 0), rgba(249, 115, 22, 0.9));
    }

    .crosshair::after {
      width: 14px;
      height: 3px;
      background: linear-gradient(to right, rgba(249, 115, 22, 0), rgba(249, 115, 22, 0.9));
    }

    /* Start overlay */
    .start-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.65), rgba(0, 0, 0, 0.96)),
        url("https://images.pexels.com/photos/167404/pexels-photo-167404.jpeg?auto=compress&cs=tinysrgb&w=1200") center/cover no-repeat;
      z-index: 20;
      transition: opacity 0.6s ease;
    }

    .start-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-card {
      padding: 20px 22px 18px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: radial-gradient(circle at top left, rgba(30, 64, 175, 0.68), rgba(15, 23, 42, 0.96));
      max-width: 420px;
      width: min(90vw, 420px);
      color: #e5e7eb;
      box-shadow:
        0 0 78px rgba(15, 23, 42, 0.98),
        0 0 120px rgba(15, 23, 42, 0.95);
      text-shadow: 0 0 22px rgba(15, 23, 42, 0.9);
    }

    .start-eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.26em;
      font-size: 10px;
      color: #a5b4fc;
      margin-bottom: 8px;
    }

    .start-title {
      font-size: 24px;
      font-weight: 800;
      margin-bottom: 6px;
    }

    .start-title span {
      display: block;
    }

    .start-sub {
      font-size: 12px;
      color: #d1d5db;
      margin-bottom: 14px;
      line-height: 1.5;
    }

    .start-sub strong {
      color: #f97316;
      font-weight: 600;
    }

    .start-meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 14px;
      font-size: 11px;
    }

    .start-meta {
      flex: 1 1 120px;
      color: #9ca3af;
      line-height: 1.4;
    }

    .start-meta span {
      color: #e5e7eb;
      font-weight: 500;
    }

    .start-controls {
      font-size: 11px;
      color: #e5e7eb;
      margin-bottom: 14px;
      line-height: 1.6;
    }

    .start-controls-key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(30, 64, 175, 0.75));
      font-size: 10px;
      margin-right: 4px;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.9);
    }

    .start-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    .primary-btn {
      appearance: none;
      border: none;
      outline: none;
      border-radius: 999px;
      padding: 8px 18px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #0b1020;
      background: radial-gradient(circle at top left, #f97316, #ea580c);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow:
        0 12px 30px rgba(249, 115, 22, 0.45),
        0 0 20px rgba(249, 115, 22, 0.7);
      transition:
        transform 0.15s ease,
        box-shadow 0.15s ease,
        filter 0.15s ease;
    }

    .primary-btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow:
        0 18px 40px rgba(249, 115, 22, 0.55),
        0 0 24px rgba(249, 115, 22, 0.9);
    }

    .primary-btn:active {
      transform: translateY(0);
      box-shadow:
        0 8px 18px rgba(249, 115, 22, 0.45),
        0 0 16px rgba(249, 115, 22, 0.7);
    }

    .primary-btn-icon {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 2px solid #0b1020;
      border-left-color: transparent;
      border-bottom-color: transparent;
      transform: rotate(45deg);
    }

    .start-hint {
      font-size: 10px;
      color: #9ca3af;
      text-align: right;
      flex: 1 1 auto;
    }

    .start-hint strong {
      color: #e5e7eb;
    }

    /* Mobile notice */
    .mobile-badge {
      position: fixed;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      padding: 4px 9px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.75);
      font-size: 10px;
      color: #e5e7eb;
      backdrop-filter: blur(8px);
      z-index: 25;
      display: none;
    }

    .mobile-badge span {
      color: #f97316;
      font-weight: 600;
    }

    @media (max-width: 720px) {
      .mobile-badge {
        display: inline-flex;
      }
      .hud-card {
        padding: 5px 8px;
        min-width: 70px;
      }
      .brand-sub {
        max-width: 240px;
      }
    }
  </style>
</head>
<body>
  <!-- UI overlay -->
  <div class="ui-root">
    <div class="ui-safe">
      <div class="ui-top">
        <div class="brand-block">
          <div class="brand-kicker">Cave survival experience</div>
          <div class="brand-title">
            <span>CAVE OF</span>
            <span>ECHOES</span>
          </div>
          <div class="brand-sub">
            A mysterious cave system waits beneath the surface. <strong>Explore, survive</strong>, and listen closely:
            the stone remembers every step you take.
          </div>
        </div>

        <div class="meta-block">
          <div class="meta-line meta-key">Quick brief</div>
          <div class="meta-line">Click to lock mouse &middot; WASD to move &middot; Follow the glow, avoid the red</div>
          <div class="pill-row">
            <div class="pill">
              <span class="pill-dot"></span>
              <span>20 Levels</span>
            </div>
            <div class="pill">
              <span class="pill-dot"></span>
              <span>Dynamic enemies</span>
            </div>
            <div class="pill">
              <span class="pill-dot"></span>
              <span>Puzzles &amp; paths</span>
            </div>
            <div class="pill bad">
              <span class="pill-dot"></span>
              <span>Boss echoes deeper in</span>
            </div>
          </div>
        </div>
      </div>

      <div class="ui-bottom">
        <div class="hint">
          <div class="hint-label">Mouse & movement</div>
          <div class="hint-main">
            Click inside the cave to <span>lock the cursor</span>, then use <span>WASD</span> to explore.
            The faint blue light marks the path forward.
          </div>
        </div>

        <div class="hud">
          <div class="hud-card">
            <div class="hud-label">Level</div>
            <div class="hud-value" id="hud-level">1 / 20</div>
            <div class="hud-sub">Reach the glowing exit to advance</div>
          </div>
          <div class="hud-card bad">
            <div class="hud-label">Echoes nearby</div>
            <div class="hud-value" id="hud-enemies">0</div>
            <div class="hud-sub">Red silhouettes will drain your light</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Crosshair -->
  <div class="crosshair"></div>

  <!-- Start overlay -->
  <div class="start-overlay" id="startOverlay">
    <div class="start-card">
      <div class="start-eyebrow">Cinematic cave run</div>
      <div class="start-title">
        <span>CAVE OF</span>
        <span>ECHOES</span>
      </div>
      <div class="start-sub">
        You wake at the mouth of an impossible cavern, lit only by cold, distant echoes of blue light.
        <strong>Every step forward wakes something older than memory.</strong>
      </div>

      <div class="start-meta-row">
        <div class="start-meta">
          Depth contract<br />
          <span>20 handcrafted layers of stone, mist and echoes. Survive long enough to see the last one.</span>
        </div>
        <div class="start-meta">
          Encounter profile<br />
          <span>Twisting corridors, shifting silhouettes, and wandering red fragments that feed on your light.</span>
        </div>
      </div>

      <div class="start-controls">
        <div><span class="start-controls-key">W</span><span class="start-controls-key">A</span><span class="start-controls-key">S</span><span class="start-controls-key">D</span> Move through the cave</div>
        <div><span class="start-controls-key">Mouse</span> Look around, track distant echoes</div>
        <div><span class="start-controls-key">Click</span> Lock your cursor and commit</div>
      </div>

      <div class="start-actions">
        <button class="primary-btn" id="startButton">
          <span>Start adventure</span>
          <span class="primary-btn-icon"></span>
        </button>
        <div class="start-hint">
          Best experienced with <strong>headphones</strong> and low room light.<br />
          Cursor lock is required to move freely.
        </div>
      </div>
    </div>
  </div>

  <div class="mobile-badge">
    This cave is tuned for <span>keyboard + mouse</span>. Some controls may feel limited on touch.
  </div>

  <!-- Three.js & controls -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // -----------------------------
    // Basic THREE.js setup
    // -----------------------------
    let scene, camera, renderer, controls;
    let clock;
    let playerLight;
    let level = 1;
    const maxLevel = 20;

    const enemyMeshes = [];
    let glowPortal;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    const hudLevel = document.getElementById("hud-level");
    const hudEnemies = document.getElementById("hud-enemies");
    const startOverlay = document.getElementById("startOverlay");
    const startButton = document.getElementById("startButton");

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x02030a);
      scene.fog = new THREE.Fog(0x02030a, 5, 60);

      clock = new THREE.Clock();

      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 1.7, 0);

      renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Player controls
      controls = new THREE.PointerLockControls(camera, document.body);
      controls.getObject().position.set(0, 1.7, 0);
      scene.add(controls.getObject());

      // Lighting
      const ambient = new THREE.AmbientLight(0x111827, 0.8);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0x4069ff, 0.5);
      dirLight.position.set(20, 40, 0);
      dirLight.castShadow = true;
      dirLight.shadow.camera.near = 5;
      dirLight.shadow.camera.far = 120;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      playerLight = new THREE.PointLight(0x60a5fa, 1.6, 28, 1.2);
      playerLight.castShadow = true;
      playerLight.shadow.mapSize.set(1024, 1024);
      controls.getObject().add(playerLight);

      buildCaveLevel(level);

      // Events
      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);
      window.addEventListener("resize", onWindowResize);

      // Start button: lock pointer & hide overlay
      startButton.addEventListener("click", () => {
        controls.lock();
      });

      controls.addEventListener("lock", () => {
        startOverlay.classList.add("hidden");
      });

      controls.addEventListener("unlock", () => {
        startOverlay.classList.remove("hidden");
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          moveForward = true;
          break;
        case "ArrowLeft":
        case "KeyA":
          moveLeft = true;
          break;
        case "ArrowDown":
        case "KeyS":
          moveBackward = true;
          break;
        case "ArrowRight":
        case "KeyD":
          moveRight = true;
          break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          moveForward = false;
          break;
        case "ArrowLeft":
        case "KeyA":
          moveLeft = false;
          break;
        case "ArrowDown":
        case "KeyS":
          moveBackward = false;
          break;
        case "ArrowRight":
        case "KeyD":
          moveRight = false;
          break;
      }
    }

    // -----------------------------
    // Cave generation
    // -----------------------------
    function buildCaveLevel(levelIndex) {
      // cleanup
      for (let i = enemyMeshes.length - 1; i >= 0; i--) {
        const mesh = enemyMeshes[i];
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
      enemyMeshes.length = 0;

      if (glowPortal) {
        scene.remove(glowPortal);
        glowPortal.geometry.dispose();
        glowPortal.material.dispose();
        glowPortal = null;
      }

      // remove old cave chunks except controls object
      const toRemove = [];
      scene.traverse((obj) => {
        if (obj.userData && obj.userData.isCaveChunk) {
          toRemove.push(obj);
        }
      });
      toRemove.forEach((obj) => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((m) => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      });

      // base floor
      const floorGeo = new THREE.PlaneGeometry(80, 80, 40, 40);
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0x020617,
        roughness: 0.9,
        metalness: 0.1
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      floor.userData.isCaveChunk = true;
      scene.add(floor);

      // cave walls / ceiling noise
      const caveGeo = new THREE.SphereGeometry(60, 48, 32);
      const caveMat = new THREE.MeshStandardMaterial({
        color: 0x020617,
        roughness: 1,
        metalness: 0,
        side: THREE.BackSide
      });
      const cave = new THREE.Mesh(caveGeo, caveMat);
      cave.position.y = 10;
      cave.userData.isCaveChunk = true;
      scene.add(cave);

      // some stalagmites & stalactites
      const stalagMaterial = new THREE.MeshStandardMaterial({
        color: 0x0b1120,
        roughness: 0.9,
        metalness: 0.1
      });

      const stalagGeo = new THREE.ConeGeometry(0.8, 4, 6);
      const stalagGeo2 = new THREE.ConeGeometry(1.0, 6, 6);

      const rnd = new THREE.Vector3();
      for (let i = 0; i < 40; i++) {
        rnd.set(
          (Math.random() - 0.5) * 50,
          0,
          (Math.random() - 0.5) * 50
        );
        const g = Math.random() > 0.5 ? stalagGeo : stalagGeo2;
        const m = new THREE.Mesh(g, stalagMaterial);
        m.position.set(rnd.x, 0, rnd.z);
        m.rotation.y = Math.random() * Math.PI * 2;
        m.castShadow = true;
        m.receiveShadow = true;
        m.userData.isCaveChunk = true;
        scene.add(m);

        // mirrored stalactite from ceiling
        const top = m.clone();
        top.position.y = 20;
        top.rotation.x = Math.PI;
        scene.add(top);
      }

      // glowing path lights
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x60a5fa
      });
      const glowGeo = new THREE.CylinderGeometry(0.15, 0.3, 1.2, 12);
      for (let i = 0; i < 14; i++) {
        const gx = (Math.random() - 0.5) * 20;
        const gz = -i * 8 - 6;
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        glowMesh.position.set(gx, 0.6, gz);
        glowMesh.userData.isCaveChunk = true;
        scene.add(glowMesh);

        const glow = new THREE.PointLight(0x60a5fa, 0.9, 16, 2);
        glow.position.set(gx, 1.4, gz);
        glow.userData.isCaveChunk = true;
        scene.add(glow);
      }

      // exit portal further down the path
      const portalZ = -120 - levelIndex * 2;
      const portalGeo = new THREE.RingGeometry(2.2, 2.6, 48);
      const portalMat = new THREE.MeshBasicMaterial({
        color: 0x93c5fd,
        side: THREE.DoubleSide
      });
      glowPortal = new THREE.Mesh(portalGeo, portalMat);
      glowPortal.position.set(0, 3, portalZ);
      glowPortal.rotation.y = Math.PI;
      glowPortal.userData.isPortal = true;
      scene.add(glowPortal);

      const portalLight = new THREE.PointLight(0x93c5fd, 2.4, 40, 1.8);
      portalLight.position.set(0, 5, portalZ + 4);
      portalLight.userData.isCaveChunk = true;
      scene.add(portalLight);

      // enemies (red echoes)
      const enemyCount = Math.min(4 + levelIndex * 0.8, 18);
      const enemyGeo = new THREE.SphereGeometry(0.6, 16, 16);
      const enemyMat = new THREE.MeshStandardMaterial({
        color: 0xef4444,
        emissive: 0x7f1d1d,
        emissiveIntensity: 0.8,
        roughness: 0.4,
        metalness: 0.3
      });

      for (let i = 0; i < enemyCount; i++) {
        const ex = (Math.random() - 0.5) * 24;
        const ez = -Math.random() * 110 - 10;
        const enemy = new THREE.Mesh(enemyGeo, enemyMat);
        enemy.castShadow = true;
        enemy.position.set(ex, 1.2 + Math.random() * 1.2, ez);
        enemy.userData.isEnemy = true;
        enemy.userData.baseY = enemy.position.y;
        enemy.userData.phase = Math.random() * Math.PI * 2;
        enemyMeshes.push(enemy);
        scene.add(enemy);
      }

      updateHUD();
      // reset player at start of level
      controls.getObject().position.set(0, 1.7, 10);
    }

    function updateHUD() {
      hudLevel.textContent = level + " / " + maxLevel;
      hudEnemies.textContent = enemyMeshes.length.toString();
    }

    // -----------------------------
    // Game loop
    // -----------------------------
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const speed = 8.0;

      if (controls.isLocked === true) {
        // apply damping
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        // keep y fixed
        controls.getObject().position.y = 1.7;

        // sync player light
        playerLight.position.set(0, 0, 0);

        updateEnemies(delta);
        checkCollisions();
      } else {
        // idle animation even if not locked
        updateEnemies(delta * 0.5);
      }

      renderer.render(scene, camera);
    }

    function updateEnemies(delta) {
      const playerPos = controls.getObject().position;

      for (let i = 0; i < enemyMeshes.length; i++) {
        const e = enemyMeshes[i];
        const phase = e.userData.phase || 0;
        e.userData.phase = phase + delta * 1.6;

        // bobbing
        e.position.y = e.userData.baseY + Math.sin(e.userData.phase * 2) * 0.25;

        // face the player
        e.lookAt(playerPos);

        const toPlayer = new THREE.Vector3().subVectors(playerPos, e.position);
        const dist = toPlayer.length();

        // move a bit towards player if within a certain radius
        if (dist < 30 && dist > 2) {
          toPlayer.normalize();
          const chaseSpeed = 2.2 + Math.min(level, 10) * 0.1;
          e.position.addScaledVector(toPlayer, chaseSpeed * delta);
        }
      }
    }

    function checkCollisions() {
      const playerPos = controls.getObject().position;

      // Portal collision
      if (glowPortal) {
        const dPortal = playerPos.distanceTo(glowPortal.position);
        if (dPortal < 3.0) {
          // Next level
          level++;
          if (level > maxLevel) {
            level = maxLevel;
            // simple "completion" flash
            hudLevel.textContent = "Depth reached";
          } else {
            buildCaveLevel(level);
          }
        }
      }

      // Enemy proximity (simple feedback via light)
      let closestEnemyDist = Infinity;
      enemyMeshes.forEach((e) => {
        const d = playerPos.distanceTo(e.position);
        if (d < closestEnemyDist) closestEnemyDist = d;
      });

      // set light color based on threat
      if (closestEnemyDist < 5) {
        playerLight.color.setHex(0xf97316);
        playerLight.intensity = 2.2;
      } else if (closestEnemyDist < 12) {
        playerLight.color.setHex(0xfb7185);
        playerLight.intensity = 1.9;
      } else {
        playerLight.color.setHex(0x60a5fa);
        playerLight.intensity = 1.6;
      }
    }
  </script>
</body>
</html>