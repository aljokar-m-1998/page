<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui, viewport-fit=cover">
<meta name="theme-color" content="#1a1a1a">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Rabbit Rush Deluxe - V6.1 Combat & Feasible Platforming</title>
<style>
    /* ... (CSS remains mostly the same for UI/Layout) ... */
    :root { --c-bg: #1a1a1a; --c-ui: rgba(0,0,0,0.9); --c-acc: #00f0ff; --c-txt: #eee; --font: 'Courier New', monospace; }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: none; user-select: none; -webkit-user-select: none; outline: none; }
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--c-bg); overflow: hidden; font-family: var(--font); color: var(--c-txt); }

    #app { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #000; }
    canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

    #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; }

    .screen { position: absolute; inset: 0; background: var(--c-ui); backdrop-filter: blur(4px); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; transition: opacity 0.2s, visibility 0.2s; z-index: 20; padding: 20px; text-align: center; }
    .hidden { opacity: 0; pointer-events: none; visibility: hidden; }

    h1 { font-size: 3rem; color: var(--c-acc); text-shadow: 0 4px 0 #000; margin: 0 0 10px; text-transform: uppercase; letter-spacing: -2px; }
    h2 { font-size: 1.2rem; color: #aaa; margin-bottom: 30px; }
    .panel { background: rgba(255,255,255,0.05); padding: 20px; border-radius: 8px; border: 1px solid #444; width: 100%; max-width: 400px; }

    button { background: #333; color: #fff; border: 2px solid #555; padding: 12px 24px; margin: 8px; font-size: 1rem; font-family: var(--font); font-weight: bold; cursor: pointer; text-transform: uppercase; width: 100%; max-width: 280px; transition: 0.1s; border-radius: 4px; box-shadow: 0 4px 0 #000; }
    button:active { transform: translateY(2px); box-shadow: 0 2px 0 #000; background: #444; border-color: var(--c-acc); }
    button.primary { border-color: var(--c-acc); color: var(--c-acc); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }

    .row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin: 8px 0; }
    input[type=range] { flex: 1; margin: 0 10px; }

    #hud { padding: 10px 15px; width: 100%; display: flex; justify-content: space-between; pointer-events: none; text-shadow: 1px 1px 0 #000; font-weight: bold; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent); }
    .stat-box { display: flex; flex-direction: column; gap: 4px; }
    .bar-wrap { width: 120px; height: 10px; background: #333; border: 1px solid #fff; position: relative; }
    .hp-fill { height: 100%; background: #f04; width: 100%; transition: width 0.2s; }
    .armor-fill { position: absolute; top: 0; left: 0; height: 100%; background: #00f0ff; width: 0%; transition: width 0.2s; opacity: 0.7; }

    #dialogue { position: absolute; top: 0; left: 0; font-size: 10px; color: #000; background: #fff; border: 1px solid #000; padding: 2px 5px; border-radius: 8px; pointer-events: none; transform: translate(-50%, -100%); white-space: nowrap; max-width: 150px; text-align: center; }

    #controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 160px; pointer-events: none; z-index: 15; padding: 10px; display: flex; justify-content: space-between; }
    .zone { pointer-events: auto; background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.15); border-radius: 16px; backdrop-filter: blur(2px); transition: 0.1s; display: flex; align-items: center; justify-content: center; font-size: 24px; color: rgba(255,255,255,0.5); }
    .zone:active, .zone.active { background: rgba(0,255,0,0.2); border-color: var(--c-acc); transform: scale(0.95); }

    #dpad { display: flex; gap: 10px; height: 100%; width: 180px; }
    .d-btn { flex: 1; height: 100%; }

    #actions { display: flex; gap: 5px; height: 100%; width: 250px; justify-content: flex-end; align-items: flex-end; } 
    .a-btn { width: 70px; height: 70px; border-radius: 50%; }
    .a-btn.big { width: 85px; height: 85px; background: rgba(100,255,100,0.1); }

    @media(min-width: 800px) { #controls { display: none; } }
</style>
</head>
<body>

<div id="app">
    <canvas id="cvs"></canvas>
    <div id="ui">
        <div id="hud">
            <div class="stat-box">
                <div class="bar-wrap"><div id="hud-armor" class="armor-fill"></div><div id="hud-hp" class="hp-fill"></div></div>
                <span id="hud-score">SCORE: 0</span>
            </div>
            <div class="stat-box" style="align-items: flex-end; font-size: 12px;">
                <span id="hud-lvl">LVL: 1</span>
                <span id="hud-seed" style="color:#888">SEED: RABBIT</span>
            </div>
        </div>
        <div id="console"></div>
    </div>

    <div id="pause-icon">||</div>

    <div id="controls">
        <div id="dpad">
            <div class="zone d-btn" data-key="Left">‚óÑ</div>
            <div class="zone d-btn" data-key="Right">‚ñ∫</div>
        </div>
        <div id="actions">
            <div class="zone a-btn" data-key="Shoot">‚óè</div>
            <div class="zone a-btn" data-key="Melee">‚öî</div> 
            <div class="zone a-btn big" data-key="Jump">‚ñ≤</div>
        </div>
    </div>

    <div id="scr-start" class="screen">
        <h1>Rabbit Rush Deluxe</h1>
        <h2>Combat & Feasible Platforming</h2>
        <div class="panel">
            <button id="btn-continue" class="primary hidden">Continue</button>
            <button id="btn-play">New Game</button>
            <button id="btn-shop">Upgrade Shop üí∞</button> 
            <button id="btn-lab">ProcGen Lab</button>
            <button id="btn-settings">Settings</button>
            <button id="btn-about">About</button> </div>
    </div>
    <div id="scr-shop" class="screen hidden">
        <h1>Upgrade Shop üí∞</h1>
        <h2>Use your Score to upgrade!</h2>
        <div class="panel">
            <pre id="shop-status" style="margin-bottom: 20px; color: var(--c-acc); font-weight: bold; text-align: left;"></pre>

            <button id="btn-buy-damage" data-cost="500">Upgrade Damage (+5) - 500 Pts</button>
            <button id="btn-buy-hp" data-cost="1000">Buy Max HP (+500) - 1000 Pts</button>
            <button id="btn-buy-speed" data-cost="1500">Upgrade Movement Speed (+25) - 1500 Pts</button>

            <button onclick="UI.back()">Back</button>
        </div>
    </div>
    <div id="scr-settings" class="screen hidden">
        <h1>Settings</h1>
        <div class="panel">
            <div class="row"><span>Master Vol</span> <input type="range" id="opt-vol" min="0" max="100" value="50"></div>
            <div class="row"><span>Music</span> <input type="checkbox" id="opt-mus" checked></div>
            <div class="row"><span>SFX</span> <input type="checkbox" id="opt-sfx" checked></div>
            <div class="row"><span>Quality</span> <select id="opt-qual"><option value="h">High</option><option value="l">Low</option></select></div>
            <div class="row"><span>Debug</span> <input type="checkbox" id="opt-dbg"></div>
            <button onclick="UI.back()">Back</button>
        </div>
    </div>
    <div id="scr-lab" class="screen hidden">
        <h1>ProcGen Lab</h1>
        <div class="panel">
            <div class="row"><span>Seed</span> <input type="text" id="lab-seed" value="perfect"></div>
            <div class="row"><span>Diff (1-10)</span> <input type="range" id="lab-diff" min="1" max="10" value="3"></div>
            <button id="btn-lab-run" class="primary">Generate & Play</button>
            <button onclick="UI.back()">Back</button>
        </div>
    </div>
    <div id="scr-about" class="screen hidden">
        <h1>About Rabbit Rush Deluxe</h1>
        <h2>Combat & Feasible Platforming</h2>
        <div class="panel">
            <p>Game Version: V6.1 - Enhanced Graphics and Combat</p>
            <p>A fast-paced pixel platformer focused on fair movement, combat and upgrades.</p>
            <p style="color:#00f0ff; font-weight:bold;">Development: Mahmoud Hassn & Anya</p>
            <button onclick="UI.back()">Back</button>
        </div>
    </div>
    <div id="scr-pause" class="screen hidden">
        <h1>PAUSED</h1>
        <div class="panel">
            <button onclick="Game.resume()" class="primary">Resume</button>
            <button onclick="UI.show('scr-settings')">Options</button>
            <button onclick="Game.quit()" class="danger">Quit to Menu</button>
        </div>
    </div>

    <div id="scr-res" class="screen hidden">
        <h1 id="res-title">Level Clear!</h1>
        <h2 id="res-stats">Score: 0</h2>
        <div class="panel">
            <button id="btn-next" class="primary">Next Level</button>
            <button onclick="Game.replay()">Replay</button>
            <button onclick="Game.quit()" class="danger">Menu</button>
        </div>
    </div>
</div>

<div id="dialogue" style="visibility: hidden;"></div>

<script>
/**
 * RABBIT RUSH ENGINE - DELUXE EDITION V6.1 
 * * * KEY ENHANCEMENTS:
 * 1. FEASIBLE PLATFORMING: Re-tuned isReachable for easier platform generation (tighter vertical limits).
 * 2. GRAPHICS OVERHAUL: Improved GFX for player, enemies, and tiles (Pixel Art Style).
 * 3. COMBAT FOCUS: Increased Enemy HP for better engagement and added Shooter enemy targeting logic.
 */

// --- 1. CORE UTILS & CONSTANTS ---
const C = {
    // PHYSICS: Lower G and Higher JUMP for much easier, more responsive platforming.
    G: 1200, T_VEL: 900, PLR_SPD: 350, 
    JUMP: -600, DBL_JUMP: -450, 

    TILE: 40, WIDTH: 0, HEIGHT: 0, MAX_LEVEL: 30,
    FIXED_DT: 1/60, 
    MELEE_RANGE: 60, 
    BASE_DMG: 1, 
    BASE_SPEED: 350, 
};

const LOG = (msg) => {
    const c = document.getElementById('console');
    c.innerText = `[${new Date().toLocaleTimeString()}] ${msg}\n` + c.innerText;
    if(c.innerText.length > 500) c.innerText = c.innerText.substring(0,500);
};

const M = {
    clamp: (v,min,max) => Math.min(Math.max(v, min), max),
    overlap: (a,b) => a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y,
    distSq: (p1, p2) => Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2),
    dist: (p1, p2) => Math.sqrt(M.distSq(p1, p2)),
};

// --- 2. STORAGE (Unchanged) ---
const Store = {
    key: 'rr_save_v6_deluxe', 
    data: { 
        seed: 'rabbit', lvl: 1, score: 0, 
        p_hp: 100, p_max_hp: 100, p_dmg: C.BASE_DMG, p_speed: C.BASE_SPEED, 
        opt: { vol:50, mus:true, sfx:true, qual:'h', dbg:false } 
    },
    load: function() {
        try {
            const s = localStorage.getItem(this.key);
            if(s) this.data = {...this.data, ...JSON.parse(s)};
        } catch(e) { LOG("Save load fail"); }
        this.data.p_max_hp = this.data.p_max_hp || 100;
        this.data.p_hp = M.clamp(this.data.p_hp || 100, 1, this.data.p_max_hp);
        this.data.p_dmg = this.data.p_dmg || C.BASE_DMG;
        this.data.p_speed = this.data.p_speed || C.BASE_SPEED;
        return this.data;
    },
    save: function() {
        if(Game.plr) {
            this.data.p_hp = Game.plr.hp;
            this.data.p_max_hp = Game.plr.maxHP;
            this.data.p_dmg = Game.plr.meleeDmg;
            this.data.p_speed = Game.plr.currentSpeed; 
        }
        try { localStorage.setItem(this.key, JSON.stringify(this.data)); } catch(e){}
    }
};

// --- 3. AUDIO SYSTEM (Unchanged) ---
const Aud = (() => {
    let ctx, master;
    let notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88];
    let loopId = null;

    const init = () => {
        if(ctx) return;
        try {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            master = ctx.createGain();
            master.connect(ctx.destination);
            setVol(Store.data.opt.vol);
        } catch(e) { LOG("Audio init fail"); }
    };

    const setVol = (v) => { if(master) master.gain.value = v/100; };

    const playTone = (freq, type, dur, vol, slide=0) => {
        if(!ctx || !Store.data.opt.sfx) return;
        if(ctx.state === 'suspended') ctx.resume();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, ctx.currentTime);
        if(slide) o.frequency.linearRampToValueAtTime(freq+slide, ctx.currentTime+dur);
        g.gain.setValueAtTime(0, ctx.currentTime);
        g.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        o.connect(g); g.connect(master);
        o.start(); o.stop(ctx.currentTime + dur + 0.1);
    };

    const noise = (dur, vol) => {
        if(!ctx || !Store.data.opt.sfx) return;
        const b = ctx.createBuffer(1, ctx.sampleRate*dur, ctx.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
        const s = ctx.createBufferSource(); s.buffer = b;
        const g = ctx.createGain();
        g.gain.setValueAtTime(vol, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0, ctx.currentTime+dur);
        s.connect(g); g.connect(master);
        s.start();
    };

    const musLoop = () => {
        if(!Store.data.opt.mus || !ctx) return;
        let n = notes[Math.floor(Math.random()*notes.length)];
        let oct = Math.random()>0.5 ? 1 : 2;
        playTone(n*oct, 'triangle', 0.3, 0.05);
        loopId = setTimeout(musLoop, 250);
    };

    return {
        init, setVol,
        startMus: () => { if(loopId) clearTimeout(loopId); musLoop(); },
        stopMus: () => { if(loopId) clearTimeout(loopId); loopId = null; },
        sfx: {
            jump: () => playTone(400, 'square', 0.1, 0.1, 100), 
            shoot: () => { noise(0.1, 0.1); playTone(800, 'sawtooth', 0.1, 0.05, -400); },
            hit: () => { playTone(150, 'sawtooth', 0.2, 0.2, -100); noise(0.2, 0.1); },
            coin: () => { [0,50].forEach((t,i) => setTimeout(()=>playTone(1200+i*600,'sine',0.1,0.1), t)); },
            win: () => { [0,200,400].forEach((t,i) => setTimeout(()=>playTone(400+i*100,'square',0.3,0.1), t)); },
            heal: () => { playTone(2000, 'sine', 0.1, 0.1); },
            armor: () => { [0,50].forEach((t,i) => setTimeout(()=>playTone(1500+i*1000,'square',0.1,0.1), t)); },
            boost: () => { playTone(1800, 'triangle', 0.1, 0.1, 500); }
        }
    };
})();

// --- 4. INPUT (Unchanged) ---
const Inp = (() => {
    const s = { l:0, r:0, j:0, f:0, m:0 }; 
    const kMap = { ArrowLeft:'l', KeyA:'l', ArrowRight:'r', KeyD:'r', Space:'j', KeyZ:'j', KeyX:'f', KeyC:'m' };

    const handler = (e, val) => { if(kMap[e.code]) s[kMap[e.code]] = val; };
    window.addEventListener('keydown', e => handler(e, 1));
    window.addEventListener('keyup', e => handler(e, 0));

    // Touch
    const tMap = { 'Left':'l', 'Right':'r', 'Jump':'j', 'Shoot':'f', 'Melee':'m' };
    const touch = (e, active) => {
        e.preventDefault();
        const tar = e.target.closest('.zone');
        if(tar) {
            const k = tar.dataset.key;
            if(tMap[k]) s[tMap[k]] = active ? 1 : 0;
            active ? tar.classList.add('active') : tar.classList.remove('active');
        }
    };

    const ctrls = document.getElementById('controls');
    ctrls.addEventListener('touchstart', e => touch(e, true), {passive:false});
    ctrls.addEventListener('touchend', e => touch(e, false));

    return { get: () => s, reset: () => { for(let k in s) s[k]=0; } };
})();

// --- 5. GRAPHICS & ASSETS (Overhauled for Pixel Art Look) ---
const GFX = (() => {
    const cache = {};
    const mk = (k, w, h, fn) => {
        if(cache[k]) return cache[k];
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        fn(c.getContext('2d'), w, h);
        cache[k] = c;
        return c;
    };

    const init = () => {
        // Player (More defined pixel look)
        mk('plr', 32, 32, (c,w,h) => {
            // Body: Green/White for the rabbit
            c.fillStyle='#8f8'; c.fillRect(4,10,24,20);
            // Ears
            c.fillRect(4,2,6,12); c.fillRect(22,2,6,12);
            // Eyes
            c.fillStyle='#000'; c.fillRect(10,14,3,3); c.fillRect(19,14,3,3);
            // Face detail
            c.fillStyle='#fff'; c.fillRect(13,18,6,6);
            c.fillStyle='#f0f'; c.fillRect(15,22,2,2); // Nose
        });

        // Walker Enemy (Simple red blob - less detailed, more pixelated)
        mk('enm', 32, 24, (c,w,h) => {
            c.fillStyle='#f44'; c.fillRect(4,4,24,16);
            c.fillStyle='#800'; c.fillRect(8,16,4,4); c.fillRect(20,16,4,4);
            c.fillStyle='#000'; c.fillRect(10,8,2,2); c.fillRect(20,8,2,2);
        });
        // Flyer Enemy (Yellow Triangle)
        mk('flenm', 32, 24, (c,w,h) => {
            c.fillStyle='#ff0'; c.beginPath(); c.moveTo(16, 0); c.lineTo(32, 12); c.lineTo(0, 12); c.closePath(); c.fill();
            c.fillStyle='#880'; c.fillRect(10, 12, 12, 12);
        });
        // Shooter Enemy (Purple Block)
        mk('shrenm', 40, 40, (c,w,h) => {
            c.fillStyle='#f0f'; c.fillRect(5, 15, 30, 25);
            c.fillStyle='#a0a'; c.fillRect(10, 5, 20, 10);
            c.fillStyle='#000'; c.beginPath(); c.arc(20, 10, 3, 0, Math.PI*2); c.fill();
        });
        // Tank Enemy (Darker, bigger block)
        mk('tenm', 40, 40, (c,w,h) => {
            c.fillStyle='#c00'; c.fillRect(0, 10, 40, 30);
            c.fillStyle='#800'; c.fillRect(5, 5, 30, 10);
        });

        // Tile (Standard platform)
        mk('tile', 40, 40, (c,w,h) => {
            c.fillStyle='#4a4'; c.fillRect(0,0,w,8); // Grass top
            c.fillStyle='#543'; c.fillRect(0,8,w,h-8); // Dirt body
            c.fillStyle='rgba(0,0,0,0.2)'; c.fillRect(5,15,10,10); // Shadow detail
        });
        // Moving Platform (Clear gray)
        mk('mplt', 40, 40, (c,w,h) => {
            c.fillStyle='#777'; c.fillRect(0,0,w,h);
            c.fillStyle='#aaa'; c.fillRect(2,2,w-4,h-4);
        });
        // Spike (Sharper)
        mk('spk', 40, 40, (c,w,h) => {
            c.fillStyle='#999'; c.beginPath(); c.moveTo(0,40); c.lineTo(20,0); c.lineTo(40,40); c.fill();
            c.fillStyle='#bbb'; c.beginPath(); c.moveTo(5,40); c.lineTo(20,8); c.lineTo(35,40); c.fill();
        });
        // Coin (More detailed)
        mk('coin', 16, 16, (c,w,h) => {
            c.fillStyle='#fd0'; c.beginPath(); c.arc(8,8,7,0,Math.PI*2); c.fill();
            c.strokeStyle='#fa0'; c.lineWidth=2; c.stroke();
            c.fillStyle='#fa0'; c.fillRect(7,2,2,12); // Coin line
        });
        // Projectiles 
        mk('proj', 8, 8, (c,w,h) => { c.fillStyle='#8f8'; c.fillRect(0,0,8,8); }); // Player Proj (Green)
        mk('enmproj', 8, 8, (c,w,h) => { c.fillStyle='#f00'; c.fillRect(0,0,8,8); }); // Enemy Proj (Red)

        // Powerups (Unchanged)
        mk('heal', 16, 16, (c,w,h) => { c.fillStyle='#0f0'; c.fillRect(3, 6, 10, 4); c.fillRect(6, 3, 4, 10); });
        mk('armr', 16, 16, (c,w,h) => { c.fillStyle='#00f0ff'; c.fillRect(0, 5, 16, 6); c.fillStyle='#fff'; c.fillRect(4, 7, 8, 2); });
        mk('bost', 16, 16, (c,w,h) => { c.fillStyle='#ff0'; c.beginPath(); c.moveTo(0,16); c.lineTo(16,8); c.lineTo(0,0); c.fill(); c.fillStyle='#f00'; c.beginPath(); c.moveTo(4,12); c.lineTo(12,8); c.lineTo(4,4); c.fill(); });

        // Background assets (Unchanged)
        mk('tree', 64, 128, (c,w,h) => { c.fillStyle='#444'; c.fillRect(28,h/2,8,h/2); c.fillStyle='#777'; c.beginPath(); c.arc(32,h/2,30,0,7); c.fill(); });
        mk('bird', 16, 8, (c,w,h) => { c.fillStyle='#fff'; c.beginPath(); c.moveTo(0,4); c.lineTo(w/2,0); c.lineTo(w,4); c.lineTo(w/2,h); c.closePath(); c.fill(); });
    };

    return { init, get: (k) => cache[k] };
})();

// --- 6. PROCGEN (Re-tuned Reachability & Difficulty) ---
const PG = (() => {
    let _s = 1;
    const srand = (str) => { _s = 0; for(let i=0; i<str.length; i++) _s = Math.imul(31, _s) + str.charCodeAt(i)|0; };
    const rand = () => { _s = (_s * 16807) % 2147483647; return (_s-1) / 2147483646; };
    const rInt = (min, max) => Math.floor(rand() * (max - min + 1)) + min;
    const rFloat = (min, max) => rand() * (max - min) + min;

    /**
     * Re-tuned reachability check (More forgiving).
     * Reduced D_MAX for high jumps (hDiff > 0) to ensure high platforms are close.
     */
    const isReachable = (fromY, toY, dist, jumps=2) => {
        const T = C.TILE;
        const hDiff = fromY - toY; 

        const D_MAX = 350; // Max horizontal distance (for full speed)
        const H_MAX = 200; // Max vertical height allowed (double jump)

        if (dist < 0) dist = Math.abs(dist); 

        // 1. Check max horizontal distance (simple linear limit)
        if (dist > D_MAX + T/2) return false;

        // 2. Check vertical height
        if (hDiff > 0) { // Jumping Up
            if (hDiff > H_MAX) return false;
            // Tighter penalty for jumping up (1.8 instead of 1.5) -> forces closer horizontal distance for max height.
            const horizontalReach = D_MAX * (1 - hDiff / (H_MAX * 1.8)); 
            return dist <= horizontalReach + 20; 
        } 
        else { // Jumping Down or Level (less constraint)
            return dist <= D_MAX + 50; 
        }
    };


    const generate = (idx, seedStr, diff) => {
        srand(seedStr + idx);
        let retries = 50; 
        while(retries-- > 0) {
            const lvl = build(idx, diff);
            if (lvl.tiles.some(t => M.overlap(t, lvl.start))) continue; 
            return lvl; 
        }
        LOG("ProcGen failed after 50 retries, falling back to simpler design.");
        return build(idx, 1); 
    };

    const build = (idx, diff) => {
        const baseLen = 70 + (idx*10); 
        const len = baseLen + rInt(-5, 15);
        const lvl = { w: len*C.TILE, tiles: [], ents: [], start:{x:100,y:0}, exit:{x:0,y:0} };

        let h = 10; 
        let gap = 0; 
        let lastTileX = -1; 
        let lastTileY = (20-10)*C.TILE; 

        const effectiveDiff = M.clamp(diff + Math.floor(idx/3), 1, 12); 
        const T = C.TILE;

        for(let x=0; x<len; x++) {
            const isSafe = x < 5 || x > len-5;

            if(isSafe) { gap = 0; }
            else if(gap > 0) { gap--; continue; }

            let makeGap = false;
            let makePlatform = false;

            if(!isSafe) {
                 const roll = rand();
                 if(roll < 0.08) { makeGap = true; } // Slightly lower gap chance
                 else if (roll < 0.20) { makePlatform = true; } // Slightly lower platform chance
                 else if (roll < 0.40) { 
                    let prevH = h;
                    h = M.clamp(h + rInt(-2, 3), 4, 16); 
                    if(prevH === h) h = M.clamp(h + (rand() > 0.5 ? 1 : -1), 4, 16);
                 }
            }

            let currentY = (20 - h) * T; 

            if(makeGap) {
                // Gap size slightly smaller for easier platforming
                gap = rInt(1, 1 + Math.floor(effectiveDiff/3)); 
                continue;
            }

            if(makePlatform) {
                // FLOATING PLATFORM LOGIC
                const platformW = rInt(2, 4); 
                const platformX = x * T;

                let newH = M.clamp(h + rInt(-3, 3), 4, 16); 
                let newY = (20 - newH) * T;

                let requiredDist = platformX - (lastTileX + T);

                // Reachability Check (Crucial for the "Feasible Platforming" goal)
                if (requiredDist > 0 && !isReachable(lastTileY, newY, requiredDist)) {
                    let tries = 5;
                    while(tries-- > 0) {
                        newH = M.clamp(newH + rInt(-1, 1), 4, 16);
                        newY = (20 - newH) * T;
                        if(isReachable(lastTileY, newY, requiredDist)) break;
                        if(tries === 0) newY = lastTileY; 
                    }
                }

                // Final Platform Placement
                lvl.tiles.push({x:platformX, y:newY, w:platformW*T, h:T, t:'tile'});
                lastTileX = platformX + platformW * T - T; 
                lastTileY = newY;

                x += platformW; 
                gap = rInt(1, 2); 
                continue; 
            }

            // SOLID GROUND / TERRAIN SLOPE
            for(let y=20-h; y<25; y++) lvl.tiles.push({x:x*T, y:y*T, w:T, h:T, t:'tile'});

            if (x * T > lastTileX) {
                lastTileX = x * T; 
                lastTileY = (20 - h) * T;
            }

            // Entity Placement (Avoid placing spikes/enemies too close to start/exit)
            const topY = (20-h)*T;
            if(x>5 && x<len-5) {
                const featureRoll = rand();

                if(featureRoll < 0.03*effectiveDiff) { // Spikes (Reduced chance)
                    lvl.ents.push({t:'spk', x:x*T, y:topY-T, w:T, h:T});
                } else if(featureRoll < 0.15*effectiveDiff) { // Enemies
                    let type = 'enm';
                    const enemyTypeRoll = rand();
                    // Balanced distribution and higher difficulty requirement for tank
                    if (enemyTypeRoll < 0.3) type = 'flenm'; 
                    else if (enemyTypeRoll < 0.6) type = 'shrenm'; 
                    else if (enemyTypeRoll > 0.8 && effectiveDiff > 5) type = 'tenm'; // Tank (Crawler)

                    const spawnY = (type === 'flenm') ? topY - rInt(4, 8) * T : topY - 40;
                    lvl.ents.push({t:type, x:x*T, y:spawnY, w:32, h:24, vx:50 * (rand()>0.5?1:-1)});
                } else if(featureRoll < 0.20 * effectiveDiff && effectiveDiff > 3) { // Moving Platforms (Slightly less common)
                    const vertical = rand() < 0.5;
                    const moveRange = rInt(3, 5) * T; 
                    const startY = topY-T-rInt(2, 6)*T; 
                    lvl.tiles.push({t:'mplt', x:x*T, y:startY, w:T*2, h:T, 
                        p1:{x:x*T, y:startY}, p2:{x:x*T + (vertical?0:moveRange), y:startY + (vertical?moveRange:0)}});
                    x += 2; 
                } else if(featureRoll < 0.5) { // Coins
                    lvl.ents.push({t:'coin', x:x*T+T/4, y:topY-T-rInt(0,100), w:16, h:16});
                } else if(featureRoll < 0.6 && effectiveDiff > 5) { // Powerups
                    const pRoll = rand();
                    if (pRoll < 0.35) lvl.ents.push({t:'heal', x:x*T+T/4, y:topY-T-rInt(0,100), w:16, h:16});
                    else if (pRoll < 0.7) lvl.ents.push({t:'armr', x:x*T+T/4, y:topY-T-rInt(0,100), w:16, h:16});
                    else lvl.ents.push({t:'bost', x:x*T+T/4, y:topY-T-rInt(0,100), w:16, h:16});
                }
            }
        }

        lvl.start.y = (20-10)*T - 100;
        lvl.exit = { x:(len-2)*T, y:0, w:80, h:2000 };
        lvl.tiles.push({x:-40, y:0, w:40, h:2000, t:'solid'});
        lvl.tiles.push({x:len*T, y:0, w:40, h:2000, t:'solid'});
        return lvl;
    };

    return { generate };
})();

// --- 7. PHYSICS & ENTITIES ---

// Dialogue Logic (Unchanged)
const Dialogue = (() => {
    const bubble = document.getElementById('dialogue');
    let targetEnt = null;
    let timer = 0;

    const messages = [
        "Rabbit stew!", "You're too slow!", "Think you can pass?", 
        "Pathetic.", "Jump or Die!", "My spot now!", "Die!", "Prepare to fall!",
    ];

    const show = (ent, msg) => {
        targetEnt = ent;
        bubble.innerText = msg;
        bubble.style.visibility = 'visible';
        timer = 4;
    };

    const update = (dt, camX) => {
        if (targetEnt && timer > 0) {
            timer -= dt;
            const x = Math.floor(targetEnt.x - camX + targetEnt.w / 2);
            const y = Math.floor(targetEnt.y);
            bubble.style.left = `${x}px`;
            bubble.style.top = `${y}px`;

            if (timer <= 0 || targetEnt.dead) {
                targetEnt = null;
                bubble.style.visibility = 'hidden';
            }
        } else if (bubble.style.visibility === 'visible') {
            bubble.style.visibility = 'hidden';
        }
    };

    const getRandomMsg = () => messages[Math.floor(Math.random() * messages.length)];

    return { show, update, getRandomMsg };
})();


class Ent {
    constructor(t,x,y,w,h) { 
        this.t=t; this.x=x; this.y=y; this.w=w; this.h=h; this.vx=0; this.vy=0; 
        this.dead=false; this.grounded=false; 
    }
    update(dt, tiles) {
        if(this.t !== 'proj' && this.t !== 'enmproj' && this.t !== 'flenm') {
            this.vy += C.G * dt;
            this.vy = Math.min(this.vy, C.T_VEL);
        }

        this.x += this.vx * dt;
        this.col(tiles, 'x');

        this.y += this.vy * dt;
        this.col(tiles, 'y');

        if (this.vy !== 0) this.grounded = false;
    }
    col(tiles, axis) {
        const T = C.TILE;
        const dt = Game.getDT();

        const minX = Math.floor((this.x - T) / T);
        const maxX = Math.ceil((this.x + this.w + T) / T);
        const minY = Math.floor((this.y - T) / T);
        const maxY = Math.ceil((this.y + this.h + T) / T);

        const nearbyTiles = tiles.filter(t => 
            (t.t === 'tile' || t.t === 'mplt' || t.t === 'solid') && 
            t.x/T >= minX && t.x/T < maxX && 
            t.y/T >= minY && t.y/T < maxY
        );

        for(let t of nearbyTiles) {
            if(M.overlap(this, t)) {
                if(this.t === 'spk' || this.t === 'coin' || this.t === 'heal' || this.t === 'armr' || this.t === 'bost') continue;

                if(axis === 'x') {
                    this.x = (this.x < t.x) ? t.x - this.w : t.x + t.w;
                    this.vx = 0;
                    if(this.t === 'enm' || this.t === 'shrenm' || this.t === 'tenm') this.vx = -this.vx;
                } else {
                    if(this.vy > 0) { 
                        this.grounded = true; 
                        this.y = t.y - this.h; 
                        if(t.t === 'mplt' && (this.t === 'plr' || this.t === 'enm' || this.t === 'shrenm' || this.t === 'tenm')) {
                            this.x += t.vx * dt; 
                        }
                    }
                    else { this.y = t.y + t.h; }
                    this.vy = 0;
                }
            }
        }
    }
    draw(ctx, cx) {
        if(this.x+this.w < cx || this.x > cx + ctx.canvas.width) return;
        const img = GFX.get(this.t);

        ctx.save();
        const drawX = Math.floor(this.x - cx);
        const drawY = Math.floor(this.y);

        if (this.vx < 0) { 
             ctx.scale(-1, 1);
             ctx.drawImage(img, -drawX - img.width, drawY);
        } else {
             ctx.drawImage(img, drawX, drawY);
        }
        ctx.restore();

        if(Store.data.opt.dbg) {
             ctx.strokeStyle = '#f0f'; ctx.strokeRect(drawX, drawY, this.w, this.h);
        }
    }
}

class Player extends Ent {
    constructor(x,y) { 
        super('plr',x,y,24,30); 
        this.maxHP=Store.data.p_max_hp; 
        this.hp=M.clamp(Store.data.p_hp, 1, this.maxHP); 
        this.armor=0; 
        this.inv=0; 
        this.jumps=0;
        this.speedBoost = 0; 
        this.meleeDmg = Store.data.p_dmg; 
        this.currentSpeed = Store.data.p_speed; 
        this.isAttacking = false; 
        this.attackTimer = 0; 
        this.facingDir = 1; 
    }
    update(dt, tiles) {
        const i = Inp.get();
        const speed = this.currentSpeed + (this.speedBoost > 0 ? 100 : 0);

        if(this.attackTimer > 0) this.attackTimer -= dt;
        if(this.attackTimer <= 0) this.isAttacking = false;

        if(i.l) { this.vx = -speed; this.facingDir = -1; }
        else if(i.r) { this.vx = speed; this.facingDir = 1; }
        else {
            this.vx *= 0.8;
            if (Math.abs(this.vx) < 10) this.vx = 0;
        }

        // Jump (Perfected)
        if(i.j && !this.pj) {
            if(this.grounded) { this.vy = C.JUMP; this.jumps=1; this.grounded=false; Aud.sfx.jump(); }
            else if(this.jumps < 2) { this.vy = C.DBL_JUMP; this.jumps++; Aud.sfx.jump(); }
        }
        this.pj = i.j;

        // Shoot 
        if(i.f && !this.pf) {
            this.facingDir = this.vx !== 0 ? Math.sign(this.vx) : this.facingDir;
            Game.spawnProj(this.x + (this.facingDir>0?30:-10), this.y+10, this.facingDir*600, 'proj');
        }
        this.pf = i.f;

        // Melee Attack
        if(i.m && !this.pm && this.attackTimer <= 0) {
            this.attack();
        }
        this.pm = i.m; 

        super.update(dt, tiles);

        if(this.y > C.HEIGHT + 500) this.hurt(100);
        if(this.inv > 0) this.inv -= dt;
        if(this.speedBoost > 0) this.speedBoost -= dt;

        this.hp = M.clamp(this.hp, 0, this.maxHP);
    }

    attack() {
        this.isAttacking = true;
        this.attackTimer = 0.25; 
        Aud.sfx.hit(); 

        const dir = this.facingDir;
        const hitbox = {
            x: this.x + (dir > 0 ? this.w : -C.MELEE_RANGE),
            y: this.y,
            w: C.MELEE_RANGE,
            h: this.h 
        };

        Game.getEntities().forEach(e => {
            if((e.t === 'enm' || e.t === 'flenm' || e.t === 'shrenm' || e.t === 'tenm') && !e.dead && M.overlap(hitbox, e)) {
                Game.entityHit(e, this.meleeDmg); 
            }
        });
    }

    hurt(dmg) {
        if(this.inv > 0 || this.dead) return;

        if (this.armor > 0) {
            const absorbed = Math.min(this.armor, dmg);
            this.armor -= absorbed;
            dmg -= absorbed;
        }

        if (dmg > 0) this.hp -= dmg; 

        this.inv = 1; Aud.sfx.hit();
        this.vy = -300;
        this.hp = M.clamp(this.hp, 0, this.maxHP); 
        this.armor = M.clamp(this.armor, 0, 100);
    }
    heal(amount) { this.hp += amount; this.hp = M.clamp(this.hp, 0, this.maxHP); Aud.sfx.heal(); }
    addArmor(amount) { this.armor += amount; this.armor = M.clamp(this.armor, 0, 100); Aud.sfx.armor(); }
    speedBoostStart() { this.speedBoost = 5; Aud.sfx.boost(); }

    draw(ctx, cx) {
        if(this.inv > 0 && Math.floor(Date.now()/50)%2) return;

        ctx.save();
        const img = GFX.get('plr');
        const drawX = Math.floor(this.x - cx);
        const drawY = Math.floor(this.y);
        const currentDir = this.facingDir; 

        if (currentDir < 0) { 
             ctx.scale(-1, 1);
             ctx.drawImage(img, -drawX - img.width, drawY);
        } else {
             ctx.drawImage(img, drawX, drawY);
        }
        ctx.restore();

        // Draw Melee Attack visualization
        if(this.isAttacking) {
             const dir = this.facingDir; 
             ctx.fillStyle = '#ff0'; 
             const armLength = C.MELEE_RANGE * 0.5;
             const armStart = this.x + (dir > 0 ? this.w : -armLength) + (dir * 5); 
             ctx.fillRect(armStart - cx, this.y + 10, dir * armLength, 5); 
        }

        if(Store.data.opt.dbg && this.isAttacking) {
            const dir = this.facingDir;
            const hx = this.x + (dir > 0 ? this.w : -C.MELEE_RANGE);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)';
            ctx.strokeRect(hx - cx, this.y, C.MELEE_RANGE, this.h);
        }
    }
}

// --- Enemy Classes (Strengthened HP for better Combat) ---

class Enemy extends Ent {
    constructor(x, y, vx, hp=2, score=150, type='enm') { // Base HP increased to 2
        super(type, x, y, 32, 24);
        this.vx = vx;
        this.baseVX = Math.abs(vx);
        this.maxHP = hp;
        this.hp = hp;
        this.scoreValue = score; 
        this.dialogueTimer = 3 + Math.random() * 5;
    }
    update(dt, tiles) {
        super.update(dt, tiles);

        if(this.grounded) {
             const T = C.TILE;
             const checkX = this.x + (this.vx > 0 ? this.w + 1 : -1); 
             const checkY = this.y + this.h + 1;

             const onEdge = !tiles.some(t => 
                 (t.t === 'tile' || t.t === 'mplt') &&
                 t.x < checkX && t.x + t.w > checkX && 
                 t.y < checkY && t.y + t.h > checkY
             );

             if(onEdge) this.vx *= -1;

             if (Math.abs(this.vx) !== this.baseVX) this.vx = this.baseVX * Math.sign(this.vx);
        }

        this.dialogueTimer -= dt;
        if (this.dialogueTimer <= 0) {
            Dialogue.show(this, Dialogue.getRandomMsg());
            this.dialogueTimer = 5 + Math.random() * 5;
        }
    }
}

class FlyerEnemy extends Enemy { 
    constructor(x, y) {
        super(x, y, 70, 1, 250, 'flenm'); // Flyer remains 1 HP but higher score
        this.w = 32; this.h = 24;
        this.baseY = y;
        this.flyPhase = Math.random() * Math.PI * 2;
    }
    update(dt, tiles) {
        this.flyPhase += dt * 3;
        this.vy = Math.sin(this.flyPhase) * 50;

        this.x += this.vx * dt;
        this.col(tiles, 'x');

        this.y += this.vy * dt;

        this.dialogueTimer -= dt;
        if (this.dialogueTimer <= 0) {
            Dialogue.show(this, "Can't reach me!");
            this.dialogueTimer = 5 + Math.random() * 5;
        }
    }
}

class ShooterEnemy extends Enemy { 
    constructor(x, y) {
        super(x, y, 30, 3, 400, 'shrenm'); // HP increased to 3
        this.w = 40; this.h = 40;
        this.shootTimer = 2;
        this.shootRate = 2 + Math.random() * 1;
    }
    update(dt, tiles) {
        super.update(dt, tiles); 

        this.shootTimer -= dt;
        if (this.shootTimer <= 0) {
            this.shoot();
            this.shootTimer = this.shootRate;
        }
    }

    shoot() {
        const plr = Game.getPlr();
        if(!plr || this.dead) return;

        // Shooter looks at the player before shooting
        const targetDir = plr.x + plr.w/2 < this.x + this.w/2 ? -1 : 1;

        // Stop movement and shoot
        this.vx = 0; 

        // Delay the shot slightly for better reaction/visualization
        setTimeout(() => {
            if (this.dead) return;
            const speed = 400;
            Game.spawnProj(this.x + this.w/2 + targetDir*10, this.y + this.h/2, targetDir * speed, 'enmproj');
            Aud.sfx.shoot();

            // Resume walking after shooting
            setTimeout(() => { 
                if(!this.dead) this.vx = this.baseVX * targetDir; 
            }, 300);

        }, 100); 
    }
}

class TankEnemy extends Enemy {
    constructor(x, y, vx) {
        super(x, y, vx, 6, 800, 'tenm'); // HP increased to 6
        this.w = 40; this.h = 40; 
        this.baseVX = Math.abs(vx) * 0.5; 
    }
    update(dt, tiles) {
        super.update(dt, tiles);
    }
}


class MovingPlatform {
    constructor(x, y, w, h, p1, p2) {
        this.t = 'mplt';
        this.x=x; this.y=y; this.w=w; this.h=h; 
        this.p1 = p1; this.p2 = p2;
        this.vx=0; this.vy=0;
        this.speed = 80 + Math.random() * 40; 
        this.prog = 0; 
        this.dir = 1; 
    }
    update(dt) {
        const totalDist = M.dist(this.p1, this.p2) || 1;
        this.prog += this.dir * (this.speed / totalDist) * dt;

        let oldX = this.x, oldY = this.y;

        if (this.prog >= 1) { this.prog = 1; this.dir = -1; }
        if (this.prog <= 0) { this.prog = 0; this.dir = 1; }

        const f = this.prog;
        this.x = this.p1.x + (this.p2.x - this.p1.x) * f;
        this.y = this.p1.y + (this.p2.y - this.p1.y) * f;

        this.vx = (this.x - oldX) / dt;
        this.vy = (this.y - oldY) / dt;
    }
    draw(ctx, cx) {
        if(this.x+this.w < cx || this.x > cx + ctx.canvas.width) return;
        const img = GFX.get(this.t);
        if(img) ctx.drawImage(img, Math.floor(this.x - cx), Math.floor(this.y));
    }
}

class Coin extends Ent {
    constructor(x, y) { super('coin', x, y, 16, 16); }
    update(dt, tiles) { this.y += Math.sin(Date.now()/500) * dt * 30; }
}
class HealthPack extends Ent {
    constructor(x, y) { super('heal', x, y, 16, 16); }
    update(dt, tiles) { this.y += Math.sin(Date.now()/500 + 1.5) * dt * 30; }
}
class ArmorPack extends Ent { 
    constructor(x, y) { super('armr', x, y, 16, 16); }
    update(dt, tiles) { this.y += Math.sin(Date.now()/500 + 3) * dt * 30; }
}
class SpeedBoost extends Ent { 
    constructor(x, y) { super('bost', x, y, 16, 16); }
    update(dt, tiles) { this.y += Math.sin(Date.now()/500 + 4.5) * dt * 30; }
}
class Spike extends Ent {
    constructor(x, y) { super('spk', x, y, 40, 40); }
    update(dt, tiles) {}
}

class Projectile extends Ent {
    constructor(x, y, vx, type='proj') {
        super(type, x, y, 8, 8);
        this.vx = vx;
        this.life = 1;
        this.vy = 0;
    }
    update(dt, tiles) {
        this.x += this.vx * dt;
        this.col(tiles, 'x'); 
        this.life -= dt;

        if (this.vx === 0 && this.life > 0) this.dead = true; 
    }
}

// --- 7.5 PARALLAX BACKGROUND EFFECTS (Unchanged) ---
const BG_FX = (() => {
    let trees = [];
    let birds = [];

    const init = (lvlW, seed) => {
        trees = []; birds = [];
        const r = new Math.seedrandom(seed);

        const viewW = C.WIDTH || window.innerWidth; 

        for(let i=0; i<lvlW/C.TILE/5; i++) {
            trees.push({ x: r()*lvlW, y: C.HEIGHT*0.8 - r()*200, scale: r()*0.5 + 0.5 });
        }

        for(let i=0; i<10; i++) {
            birds.push({ x: r()*lvlW, y: r()*C.HEIGHT*0.4 + 50, vx: r()*50 + 20, vy: 0, phase: r()*Math.PI*2 });
        }
    };

    const update = (dt) => {
        const time = Date.now()/1000;
        const lvlW = Game.getLevel() ? Game.getLevel().w : 10000;

        birds.forEach(b => {
            b.x += b.vx * dt;
            b.y += Math.sin(time + b.phase) * 50 * dt;
            if(b.x > lvlW) b.x = -50;
        });
    };

    const draw = (ctx, camX) => {
        ctx.fillStyle = '#445';
        ctx.fillRect(0, 0, C.WIDTH, C.HEIGHT);

        ctx.fillStyle = '#678';
        ctx.fillRect(0, C.HEIGHT * 0.8, C.WIDTH, C.HEIGHT * 0.2);

        const treeImg = GFX.get('tree');
        if(treeImg) {
             trees.forEach(t => {
                const x = t.x - camX * 0.2;
                const y = t.y;
                const size = t.scale * 1.5;
                ctx.drawImage(treeImg, 
                    (x % C.WIDTH + C.WIDTH) % C.WIDTH, 
                    y, 
                    treeImg.width * size, 
                    treeImg.height * size);
             });
        }

        const birdImg = GFX.get('bird');
        if(birdImg) {
            birds.forEach(b => {
                const x = b.x - camX * 0.4;
                ctx.drawImage(birdImg, 
                    (x % C.WIDTH + C.WIDTH) % C.WIDTH, 
                    b.y);
            });
        }
    };

    return { init, update, draw };
})();

// --- 8. GAME ENGINE ---
const Game = (() => {
    let cvs, ctx, raf;
    let state = 'menu';
    let lvl, lvlBufferCanvas;
    let plr; 
    let ents = [], projs = [];
    let camX = 0, lastT = 0;
    let accumulator = 0;
    let lastDT = C.FIXED_DT; 

    const LOOT = { HEAL: 0.10, ARMOR: 0.05, BOOST: 0.05 };

    const init = () => {
        try {
            cvs = document.getElementById('cvs');
            ctx = cvs.getContext('2d', { alpha: false });
            resize();
            window.addEventListener('resize', resize);

            Store.load(); 
            GFX.init();
            Aud.init();

            plr = new Player(0,0);

            UI.init();

        } catch(e) { alert("Init Error: " + e.message); }
    };

    const resize = () => {
        C.WIDTH = window.innerWidth;
        C.HEIGHT = window.innerHeight;
        cvs.width = C.WIDTH; cvs.height = C.HEIGHT;
        ctx.imageSmoothingEnabled = false;
    };

    const start = (isNew, labCfg) => {
        Aud.init();
        if(isNew) {
            if(labCfg) { 
                Store.data.seed=labCfg.s; Store.data.lvl=labCfg.l; 
            } else { 
                Store.data.seed = 'rabbit'; Store.data.lvl = 1; Store.data.score = 0; 
            }
            Store.data.p_hp = 100;
            Store.data.p_max_hp = 100;
            Store.data.p_dmg = C.BASE_DMG;
            Store.data.p_speed = C.BASE_SPEED;
            Store.save();
        }

        const diff = labCfg ? labCfg.d : M.clamp(1 + Math.floor(Store.data.lvl / 2), 1, 10);
        lvl = PG.generate(Store.data.lvl, Store.data.seed, diff);
        BG_FX.init(lvl.w, Store.data.seed + Store.data.lvl);

        plr = new Player(lvl.start.x, lvl.start.y);

        ents = lvl.ents.map(e => {
            if(e.t === 'enm') return new Enemy(e.x, e.y, e.vx, 2, 150, 'enm'); // Base HP 2
            if(e.t === 'flenm') return new FlyerEnemy(e.x, e.y);
            if(e.t === 'shrenm') return new ShooterEnemy(e.x, e.y);
            if(e.t === 'tenm') return new TankEnemy(e.x, e.y, e.vx); // Base HP 6
            if(e.t === 'coin') return new Coin(e.x, e.y);
            if(e.t === 'heal') return new HealthPack(e.x, e.y);
            if(e.t === 'armr') return new ArmorPack(e.x, e.y); 
            if(e.t === 'bost') return new SpeedBoost(e.x, e.y); 
            if(e.t === 'spk') return new Spike(e.x, e.y);
            return null;
        }).filter(e => e !== null);

        lvl.tiles.filter(t => t.t === 'mplt').forEach(mp => {
            const mpEnt = new MovingPlatform(mp.x, mp.y, mp.w, mp.h, mp.p1, mp.p2);
            ents.push(mpEnt);
            Object.assign(mp, mpEnt);
        });

        projs = [];

        lvlBufferCanvas = document.createElement('canvas');
        lvlBufferCanvas.width = lvl.w;
        lvlBufferCanvas.height = C.HEIGHT; 
        const bCtx = lvlBufferCanvas.getContext('2d');
        bCtx.imageSmoothingEnabled = false;

        const tileImg = GFX.get('tile');
        const spikeImg = GFX.get('spk');

        for(let t of lvl.tiles) {
            if(t.t === 'solid' || t.t === 'mplt') continue; 
            if(t.t === 'tile') bCtx.drawImage(tileImg, t.x, t.y);
            if(t.t === 'spk') bCtx.drawImage(spikeImg, t.x, t.y);
        }

        state = 'play';
        Aud.startMus();
        loop(0);
        UI.toScreen(null);
    };

    const loop = (t) => {
        if(state !== 'play') return;
        raf = requestAnimationFrame(loop);

        const delta = (t - lastT) / 1000;
        lastT = t;
        accumulator = M.clamp(accumulator + delta, 0, 0.2); 

        while(accumulator >= C.FIXED_DT) {
            lastDT = C.FIXED_DT;
            update(C.FIXED_DT);
            accumulator -= C.FIXED_DT;
        }

        render(accumulator / C.FIXED_DT);
    };

    const spawnProj = (x, y, vx, type) => {
        projs.push(new Projectile(x, y, vx, type)); 
        if(type === 'proj') Aud.sfx.shoot();
    };

    const spawnLoot = (x, y) => {
        const roll = Math.random();
        if (roll < LOOT.HEAL) return new HealthPack(x, y);
        if (roll < LOOT.HEAL + LOOT.ARMOR) return new ArmorPack(x, y);
        if (roll < LOOT.HEAL + LOOT.ARMOR + LOOT.BOOST) return new SpeedBoost(x, y);
        return null;
    };

    const entityHit = (e, damage) => {
        e.hp -= damage; 
        if (e.hp <= 0) {
            e.dead = true;
            Store.data.score += e.scoreValue || 150; 
            Aud.sfx.hit();
            const loot = spawnLoot(e.x + e.w/2, e.y);
            if (loot) ents.push(loot);
        }
    };

    const update = (dt) => {
        plr.update(dt, lvl.tiles);
        Dialogue.update(dt, camX); 

        let target = plr.x - C.WIDTH * 0.3;
        camX += (target - camX) * 5 * dt; 
        camX = M.clamp(camX, 0, lvl.w - C.WIDTH);

        BG_FX.update(dt);

        projs.forEach(p => {
            p.update(dt, lvl.tiles);
            p.life -= dt;

            if(p.t === 'proj') { 
                ents.forEach(e => {
                    if((e.t === 'enm' || e.t === 'flenm' || e.t === 'shrenm' || e.t === 'tenm') && !e.dead && M.overlap(p, e)) { 
                        entityHit(e, 1); 
                        p.dead = true; 
                    }
                });
            } else if (p.t === 'enmproj') { 
                if(M.overlap(p, plr)) {
                    plr.hurt(15);
                    p.dead = true;
                }
            }
        });
        projs = projs.filter(p => p.life > 0 && !p.dead);

        const oldEnts = ents;
        ents = [];

        oldEnts.forEach(e => {
            if(e.dead) return;
            if(Math.abs(e.x - plr.x) > C.WIDTH*2 && e.t !== 'mplt') { ents.push(e); return; } 

            if(e.t === 'mplt') e.update(dt); 
            else e.update(dt, lvl.tiles);

            // Collision with Player
            if(M.overlap(plr, e)) {
                if(e.t === 'coin') { e.dead = true; Store.data.score += 10; Aud.sfx.coin(); }
                else if(e.t === 'heal') { e.dead = true; plr.heal(30); } 
                else if(e.t === 'armr') { e.dead = true; plr.addArmor(30); } 
                else if(e.t === 'bost') { e.dead = true; plr.speedBoostStart(); } 
                else if(e.t === 'spk') plr.hurt(25);
                else if(e.t === 'enm' || e.t === 'flenm' || e.t === 'shrenm' || e.t === 'tenm') {
                    if(plr.vy > 0 && plr.y + plr.h < e.y + e.h/2 && e.t !== 'flenm') { 
                        entityHit(e, 1); 
                        plr.vy = -400; 
                    }
                    else plr.hurt(20);
                }
            }
            if(!e.dead) ents.push(e);
        });

        if(plr.hp <= 0) gameOver();
        if(lvl.exit && M.overlap(plr, lvl.exit)) win();

        UI.hud(plr.hp, plr.armor, Store.data.score, Store.data.lvl, Store.data.seed);
    };

    const render = (interpolationFactor) => {
        BG_FX.draw(ctx, camX);

        ctx.drawImage(lvlBufferCanvas, camX, 0, C.WIDTH, C.HEIGHT, 0, 0, C.WIDTH, C.HEIGHT);

        ents.forEach(e => { 
            if(e.t === 'mplt' || !e.dead) e.draw(ctx, camX); 
        });

        projs.forEach(p => p.draw(ctx, camX));
        plr.draw(ctx, camX);

        Dialogue.update(0, camX); 

        if(Store.data.opt.dbg) {
            ctx.fillStyle='#ff0'; ctx.font = '10px monospace';
            ctx.fillText(`FPS: ${Math.round(1/0.016)} | ENT: ${ents.length} | PROJ: ${projs.length}`, 10, 20);
            ctx.fillText(`X:${plr.x.toFixed(0)} Y:${plr.y.toFixed(0)} | VY:${plr.vy.toFixed(0)} | G:${plr.grounded}`, 10, 30);
            ctx.fillText(`HP:${plr.hp.toFixed(0)}/${plr.maxHP.toFixed(0)} | ARM:${plr.armor.toFixed(0)} | DMG:${plr.meleeDmg} | SPD:${plr.currentSpeed}`, 10, 40);
        }
    };

    const gameOver = () => {
        state = 'over'; cancelAnimationFrame(raf); Aud.stopMus(); Aud.sfx.hit();
        UI.toScreen('scr-res');
        document.getElementById('res-title').innerText = "GAME OVER";
        document.getElementById('btn-next').style.display = 'none';
        document.getElementById('res-stats').innerText = `Final Score: ${Store.data.score}`;
        Store.save();
    };

    const win = () => {
        state = 'win'; cancelAnimationFrame(raf); Aud.stopMus(); Aud.sfx.win();

        const nextLevel = Store.data.lvl + 1;

        if(nextLevel > C.MAX_LEVEL) {
            Store.data.lvl = C.MAX_LEVEL; 
            document.getElementById('res-title').innerText = "GAME COMPLETE!";
            document.getElementById('btn-next').style.display = 'none';
        } else {
            Store.data.lvl = nextLevel; 
            document.getElementById('res-title').innerText = "LEVEL COMPLETE";
            document.getElementById('btn-next').style.display = 'inline-block';
        }

        Store.save();
        UI.toScreen('scr-res');
        document.getElementById('res-stats').innerText = `Score: ${Store.data.score}`;
    };

    return { 
        init, start, getLevel: () => lvl, getDT: () => lastDT,
        pause:()=>{ state='pause'; cancelAnimationFrame(raf); UI.toScreen('scr-pause'); }, 
        resume:()=>{ state='play'; UI.toScreen(null); lastT = performance.now(); loop(lastT); }, 
        quit:()=>{ state='menu'; UI.toScreen('scr-start'); Aud.stopMus(); }, 
        replay:()=>start(false), 
        spawnProj,
        entityHit,
        getEntities: () => ents,
        getPlr: () => plr 
    };
})();

// --- 9. UI MANAGE (Unchanged) ---
const UI = (() => {
    const el = (i) => document.getElementById(i);
    const screens = ['scr-start', 'scr-settings', 'scr-lab', 'scr-pause', 'scr-res', 'scr-about', 'scr-shop']; 
    let activeScreen = 'scr-start';

    const init = () => {
        el('btn-play').onclick = () => Game.start(true);
        el('btn-continue').onclick = () => Game.start(false);
        el('btn-lab').onclick = () => toScreen('scr-lab');

        el('btn-shop').onclick = () => { toScreen('scr-shop'); updateShopUI(); }; 

        el('btn-settings').onclick = () => {
            el('opt-vol').value = Store.data.opt.vol;
            el('opt-mus').checked = Store.data.opt.mus;
            el('opt-sfx').checked = Store.data.opt.sfx;
            el('opt-qual').value = Store.data.opt.qual;
            el('opt-dbg').checked = Store.data.opt.dbg;
            toScreen('scr-settings');
        };

        el('btn-about').onclick = () => toScreen('scr-about');

        el('btn-lab-run').onclick = () => {
            const s = el('lab-seed').value || 'random';
            const d = parseInt(el('lab-diff').value);
            Game.start(true, {s, d, l:1});
        };
        el('btn-next').onclick = () => Game.start(false);
        el('pause-icon').onclick = Game.pause;

        // SHOP BUTTON HANDLERS
        el('btn-buy-damage').onclick = (e) => buyUpgrade(e.target.dataset.cost, 'damage', el('btn-buy-damage'), 5, 500);
        el('btn-buy-hp').onclick = (e) => buyUpgrade(e.target.dataset.cost, 'hp', el('btn-buy-hp'), 50, 1000);
        el('btn-buy-speed').onclick = (e) => buyUpgrade(e.target.dataset.cost, 'speed', el('btn-buy-speed'), 25, 1500);


        el('opt-vol').oninput = (e) => { Store.data.opt.vol = parseInt(e.target.value); Aud.setVol(e.target.value); Store.save(); };
        el('opt-mus').onchange = (e) => { 
            Store.data.opt.mus = e.target.checked; 
            if(e.target.checked) Aud.startMus(); else Aud.stopMus(); 
            Store.save(); 
        };
        el('opt-sfx').onchange = (e) => { Store.data.opt.sfx = e.target.checked; Store.save(); };
        el('opt-qual').onchange = (e) => { Store.data.opt.qual = e.target.value; Store.save(); };
        el('opt-dbg').onchange = (e) => { Store.data.opt.dbg = e.target.checked; Store.save(); };

        if(Store.data.lvl > 1 || Store.data.score > 0) el('btn-continue').classList.remove('hidden');
    };

    const toScreen = (id) => {
        screens.forEach(s => el(s).classList.add('hidden'));
        if(id) {
            el(id).classList.remove('hidden');
            activeScreen = id;
        } else {
            activeScreen = null;
        }
    };

    const back = () => {
        Store.save();
        toScreen('scr-start');
    };

    const updateShopUI = () => {
        const plr = Game.getPlr();
        if (!plr) return; 

        el('shop-status').innerHTML = 
            `**Score:** ${Store.data.score} Pts\n` +
            `**Melee Damage:** ${plr.meleeDmg}\n` +
            `**Max HP:** ${plr.maxHP}\n` +
            `**Movement Speed:** ${plr.currentSpeed}`;

        const upgrades = [
            { id: 'btn-buy-damage', currentVal: plr.meleeDmg, baseCost: 500, inc: 5, label: 'Damage' },
            { id: 'btn-buy-hp', currentVal: plr.maxHP, baseCost: 1000, inc: 50, label: 'Max HP' },
            { id: 'btn-buy-speed', currentVal: plr.currentSpeed, baseCost: 1500, inc: 25, label: 'Speed' }
        ];

        upgrades.forEach(u => {
            const btn = el(u.id);
            const cost = parseInt(btn.dataset.cost);
            btn.disabled = Store.data.score < cost;
            btn.innerText = `Upgrade ${u.label} (+${u.inc}) - ${cost} Pts`;
        });
    };

    const buyUpgrade = (costStr, type, btnEl, inc, costStep) => {
        const cost = parseInt(costStr);
        const plr = Game.getPlr();
        if (!plr || Store.data.score < cost) return;

        Store.data.score -= cost;
        let newCost = cost + costStep;

        if(type === 'damage') {
            plr.meleeDmg += inc; 
            Store.data.p_dmg = plr.meleeDmg; 
        } else if (type === 'hp') {
            plr.maxHP += inc; 
            plr.hp = M.clamp(plr.hp + inc, 0, plr.maxHP); 
            Store.data.p_max_hp = plr.maxHP; 
            Store.data.p_hp = plr.hp; 
        } else if (type === 'speed') {
            plr.currentSpeed += inc;
            Store.data.p_speed = plr.currentSpeed;
        }

        btnEl.dataset.cost = newCost; 
        Store.save();
        updateShopUI();
        Aud.sfx.coin(); 
    };


    const hud = (hp, armor, sc, lv, seed) => { 
        const plr = Game.getPlr();
        if (!plr) return;

        const hp_percent = (hp / plr.maxHP) * 100;

        el('hud-hp').style.width = M.clamp(hp_percent, 0, 100) + '%';
        el('hud-armor').style.width = M.clamp(armor, 0, 100) + '%';
        el('hud-score').innerText = `SCORE: ${sc}`;
        el('hud-lvl').innerText = `LVL: ${lv}/${C.MAX_LEVEL}`;
        el('hud-seed').innerText = `SEED: ${seed.substring(0, 8).toUpperCase()}`;
    };

    return { init, toScreen, back, hud, show: toScreen, updateShopUI };
})();

// --- 10. PWA & BOOT (Unchanged) ---
(function Boot() {

    Math.seedrandom = function(seed) { 
        let _s = 0; for(let i=0; i<seed.length; i++) _s = Math.imul(31, _s) + seed.charCodeAt(i)|0;
        return () => (_s = (_s * 16807) % 2147483647, (_s-1) / 2147483646);
    };

    const ic = document.createElement('canvas'); ic.width=192; ic.height=192;
    const ctx = ic.getContext('2d');
    ctx.fillStyle='#222'; ctx.fillRect(0,0,192,192);
    ctx.fillStyle='#00f0ff'; ctx.beginPath(); ctx.arc(96,96,60,0,7); ctx.fill();
    ctx.fillStyle='#000'; ctx.fillRect(96 - 15 - 5, 80, 15, 15); ctx.fillRect(96 + 5, 80, 15, 15);
    const iconUrl = ic.toDataURL('image/png');

    const link = document.createElement('link'); link.rel='manifest';
    const json = JSON.stringify({
        name:"RabbitRushDeluxe", short_name:"RRDeluxe", start_url:".", display:"standalone",
        background_color:"#1a1a1a", theme_color:"#1a1a1a",
        icons:[{src:iconUrl, sizes:"192x192", type:"image/png"}]
    });
    link.href = 'data:application/manifest+json,' + encodeURIComponent(json);
    document.head.appendChild(link);

    if('serviceWorker' in navigator) {
        const sw = `
        self.addEventListener('install', e => e.waitUntil(caches.open('rr-v61').then(c => c.add(location.href))));
        self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request))));
        `;
        const blob = new Blob([sw], {type:'text/javascript'});
        navigator.serviceWorker.register(URL.createObjectURL(blob)).catch(e => LOG('SW Fail'));
    }

    window.onload = () => {
        Game.init();
    };
})();
</script>
</body>
</html>