<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„ÙŠØ¯Ùˆ - Ludo Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©</title>
    <style>
        /* Ø§Ù„Ø®Ø· Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© */
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');

        :root {
            /* ØªØ¹Ø±ÙŠÙ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ù„ÙˆØ§Ù† */
            --red: #E74C3C;
            --blue: #3498DB;
            --green: #2ECC71;
            --yellow: #F1C40F;
            --bg-color: #2c3e50;
            --game-bg: #34495e;
            --board-border: #2c3e50;
        }

        body {
            font-family: 'Cairo', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color); /* Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙƒÙ†Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #ecf0f1;
            overflow: hidden; /* Ù„Ù…Ù†Ø¹ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø£ÙÙ‚ÙŠ */
        }

        /* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
        #game-container {
            display: flex;
            flex-direction: column;
            width: 95vw;
            max-width: 500px;
            margin: auto;
            border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: var(--game-bg);
            padding: 20px 20px 10px 20px; /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¨Ø§Ø¯Ù†Ø¬ Ø§Ù„Ø³ÙÙ„ÙŠ Ù„Ø¥ÙØ³Ø§Ø­ Ù…Ø¬Ø§Ù„ Ù„Ù„Ù†Ø±Ø¯ */
        }

        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ù‚Ù…Ø§Ø´ÙŠØ© */
        #ludo-board {
            touch-action: none; /* Ù„Ù…Ù†Ø¹ Ø§Ù„Ø³Ø­Ø¨ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø¹Ø¨ */
            border-radius: 12px;
            background-color: #ddd;
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 8px solid var(--board-border); /* Ø­Ø¯ Ø³Ù…ÙŠÙƒ ÙˆØ¯Ø§ÙƒÙ† */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 5px; /* ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ù„ÙˆØ­Ø© ÙˆÙ…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ… */
        }

        /* Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ… ÙˆØ§Ù„Ø­Ø§Ù„Ø© */
        #controls-status {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 0 10px;
            width: 100%;
        }

        #status-display {
            background-color: #5d6d7e; /* Ù„ÙˆÙ† Ø±Ù…Ø§Ø¯ÙŠ Ù…Ø­Ø§ÙŠØ¯ Ù„Ù„Ø­Ø§Ù„Ø© */
            color: white;
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 40px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        /* Ù…Ø¤Ø´Ø±Ø§Øª Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ */
        .player-turn-0 { background-color: var(--red) !important; }
        .player-turn-1 { background-color: var(--blue) !important; }
        .player-turn-2 { background-color: var(--green) !important; }
        .player-turn-3 { background-color: var(--yellow) !important; color: #333 !important; } /* Ù„ÙˆÙ† Ù†Øµ Ù…Ø®ØªÙ„Ù Ù„Ù„Ø£ØµÙØ± */


        #dice-area {
            /* ÙˆØ¶Ø¹ Ø§Ù„Ù†Ø±Ø¯ ÙÙŠ Ù…Ù†ØªØµÙ Ø£Ø³ÙÙ„ Ø§Ù„Ø´Ø§Ø´Ø© (Ø®Ø§Ø±Ø¬ Ø§Ù„Ù„ÙˆØ­Ø©) */
            display: flex;
            align-items: center;
            justify-content: center;
            padding-bottom: 10px;
            margin-top: 10px;
        }

        /* Ø§Ù„Ù†Ø±Ø¯ Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¶ØºØ· (Ø§Ù„Ù…Ø­Ø³Ù†) */
        #dice-display {
            width: 70px;
            height: 70px;
            border: 4px solid #333;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em; /* ØªØµØºÙŠØ± Ø§Ù„Ø®Ø· Ù‚Ù„ÙŠÙ„Ø§Ù‹ */
            font-weight: bold;
            background-color: #f0f0f0;
            color: #333;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3), inset 0 0 15px rgba(255, 255, 255, 0.6);
            transition: all 0.15s ease;
            cursor: pointer;
            line-height: 1;
            user-select: none;
            /* Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ± Ø§Ù„Ø³Ù‡Ù…/Ø§Ù„Ù…Ø¤Ø´Ø± */
            position: relative; 
        }

        /* Ù…Ø¤Ø´Ø± Ø§Ù„Ø³Ù‡Ù… ÙÙˆÙ‚ Ø§Ù„Ù†Ø±Ø¯ Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ */
        #dice-display::after {
            content: 'â–²';
            position: absolute;
            top: -15px; /* ÙˆØ¶Ø¹Ù‡ ÙÙˆÙ‚ Ø§Ù„Ù†Ø±Ø¯ */
            font-size: 1.2em;
            color: transparent; /* Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹ ØºÙŠØ± Ù…Ø±Ø¦ÙŠ */
            text-shadow: none;
            transition: color 0.3s;
        }

        /* ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ø³Ù‡Ù… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¯ÙˆØ± Ø§Ù„Ù„Ø§Ø¹Ø¨ (ÙŠØªÙ… Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠÙ‡ Ø¨Ø§Ù„Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª) */
        #dice-display.turn-0::after { color: var(--red); }
        #dice-display.turn-1::after { color: var(--blue); }
        #dice-display.turn-2::after { color: var(--green); }
        #dice-display.turn-3::after { color: var(--yellow); }

        #dice-display.disabled {
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
            transform: none;
            background-color: #ccc;
        }

        /* Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø³Ù‡Ù… Ø¹Ù†Ø¯ Ø§Ù„ØªØ¹Ø·ÙŠÙ„ */
        #dice-display.disabled::after { color: transparent; }

        #dice-display:not(.disabled):active {
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Ø§Ù†ÙŠÙ…ÙŠØ´Ù† Ø§Ù‡ØªØ²Ø§Ø² Ø§Ù„Ù†Ø±Ø¯ (Ù„Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯) */
        @keyframes dice-roll-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            25% { transform: translate(-1px, -2px) rotate(-1deg); }
            50% { transform: translate(-3px, 0px) rotate(1deg); }
            75% { transform: translate(3px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -1px) rotate(-1deg); }
        }

        #dice-display.rolling {
            animation: dice-roll-shake 0.1s infinite;
        }

        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª/Ø§Ù„ØµÙˆØª */
        .setting-button, #mute-button {
            background: none;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            color: #ecf0f1;
            padding: 8px;
            transition: color 0.2s;
        }

        .setting-button:hover, #mute-button:hover {
            color: #3498db; /* Ø£Ø²Ø±Ù‚ Ø¬Ø°Ø§Ø¨ */
        }

        /* Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© (Modals) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s;
        }

        .modal.active {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            color: #333;
        }

        .modal-content h2 {
            color: var(--red); /* Ø£Ø­Ù…Ø± Ø¯Ø§ÙƒÙ† */
            margin-top: 0;
            font-size: 2em;
        }

        .modal-content button {
            margin-top: 15px;
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-family: 'Cairo', sans-serif;
            font-weight: bold;
        }

        .modal-content .primary-btn {
            background-color: var(--blue);
            color: white;
        }

        .modal-content .primary-btn:hover {
            background-color: #2980b9;
        }

        .modal-content .primary-btn:active {
            transform: translateY(1px);
        }

        .modal-content .secondary-btn {
            background-color: #ecf0f1;
            color: #333;
            margin-right: 10px;
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠ */
        #top-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
        }

        /* ØªÙ„ÙˆÙŠÙ† Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª */
        .player-setup-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .player-setup-row:last-child {
            border-bottom: none;
        }

        .player-setup-row select {
            border: 1px solid #bdc3c7;
            background-color: #f7f7f7;
            padding: 5px;
            border-radius: 5px;
            font-family: 'Cairo', sans-serif;
        }

        .player-setup-row label {
             min-width: 60px;
             text-align: right;
        }

        .color-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid #333;
        }

        .setup-group {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <button id="mute-button" title="ÙƒØªÙ… Ø§Ù„ØµÙˆØª/ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª">ğŸ”Š</button>
        <button id="setting-button" class="setting-button" title="Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª">âš™ï¸</button>
    </div>

    <div id="game-container">
        <canvas id="ludo-board"></canvas>

        <div id="controls-status">
            <div id="status-display">... ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ...</div>

            <div id="dice-area">
                <div id="dice-display" class="dice-display-clickable">ğŸ²</div>
            </div>
        </div>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2>ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ğŸ‰</h2>
            <p id="winner-message" style="font-size: 1.3em; margin: 20px 0;"></p>
            <button class="primary-btn" id="new-game-from-win">Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            <button class="secondary-btn" id="share-screenshot">Ù…Ø´Ø§Ø±ÙƒØ© Ù„Ù‚Ø·Ø©</button>
        </div>
    </div>

    <div id="setup-modal" class="modal active">
        <div class="modal-content">
            <h2>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ø¹Ø¨Ø© Ù„ÙŠØ¯Ùˆ</h2>

            <div id="setup-screen">
                <div class="setup-group">
                    <label for="player-count">Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†:</label>
                    <select id="player-count">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4" selected>4</option>
                    </select>
                </div>

                <div class="setup-group" id="player-config">
                    <p style="font-weight: bold; margin-bottom: 10px;">Ù†ÙˆØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†:</p>
                    </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="primary-btn" id="start-new-game">Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
                <button class="secondary-btn" id="resume-game" style="display: none;">Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            </div>
        </div>
    </div>

    <script>
    //================================================================================
    // 1. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø«ÙˆØ§Ø¨Øª ÙˆØ§Ù„Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
    //================================================================================

    const CANVAS = document.getElementById('ludo-board');
    const CTX = CANVAS.getContext('2d');
    const BASE_SIZE = 600; 

    const PLAYER_COLORS = {
        0: { name: 'Ø§Ù„Ø£Ø­Ù…Ø±', color: '#E74C3C', light: '#FADBD8' }, 
        1: { name: 'Ø§Ù„Ø£Ø²Ø±Ù‚', color: '#3498DB', light: '#D6EAF8' }, 
        2: { name: 'Ø§Ù„Ø£Ø®Ø¶Ø±', color: '#2ECC71', light: '#D1F2EB' }, 
        3: { name: 'Ø§Ù„Ø£ØµÙØ±', color: '#F1C40F', light: '#FCF3CF' } 
    };

    const ARABIC_TEXT = {
        ROLL_DICE: 'Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯',
        CURRENT_TURN: 'Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠ: ',
        ROLLED: 'Ù„Ù‚Ø¯ Ø±Ù…ÙŠØª ',
        EXTRA_TURN: 'Ø¯ÙˆØ± Ø¥Ø¶Ø§ÙÙŠ! ğŸ²',
        NO_MOVES: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù…ØªØ§Ø­Ø©ØŒ ÙŠÙ†ØªÙ‚Ù„ Ø§Ù„Ø¯ÙˆØ±.',
        HUMAN: 'Ø¨Ø´Ø±ÙŠ',
        AI: 'Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
        EASY: 'Ø³Ù‡Ù„',
        MEDIUM: 'Ù…ØªÙˆØ³Ø·',
        HARD: 'ØµØ¹Ø¨',
        WINNER_IS: 'Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ ',
        GAME_SAVED: 'ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.',
        PLAYER: 'Ø§Ù„Ù„Ø§Ø¹Ø¨ ',
        START_NEW: 'Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©',
        RESUME: 'Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©',
    };

    // ØªÙ…Øª Ù…Ø±Ø§Ø¬Ø¹Ø© Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ØŒ Ù„ÙƒÙ† Ø§Ù„Ø£Ù‡Ù… Ù‡ÙŠ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙÙŠ BOARD_CONFIG
    const SAFE_SPOTS = [1, 9, 14, 22, 27, 35, 40, 48]; // Ù…ÙˆØ§Ø¶Ø¹ Ø¢Ù…Ù†Ø© (Ø§Ù„Ù†Ø¬Ù…Ø©) - index 0-51
    const START_SPOTS = [0, 13, 26, 39]; // Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨ (ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ) - index 0-51
    const START_POSITIONS = [0, 13, 26, 39]; // 0: Red, 13: Blue, 26: Green, 39: Yellow


    // Ù…Ø³Ø§Ø± Ø§Ù„Ù„ÙˆØ­Ø© (ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ø­Ø¬Ù… BASE_SIZE) - Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ù† 0.5 Ø¥Ù„Ù‰ 14.5
    const BOARD_CONFIG = {
        // Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ Ø§Ù„Ù…Ø´ØªØ±Ùƒ (52 Ø®Ø§Ù†Ø©) - Ù…Ø³Ø§Ø± Ù„ÙˆØ¯Ùˆ 15x15 Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ
        PATH: [
            // Red Home Row to Path Start (index 0) - Bottom Right to Left
            {x: 6.5, y: 12.5}, {x: 6.5, y: 11.5}, {x: 6.5, y: 10.5}, {x: 6.5, y: 9.5}, {x: 6.5, y: 8.5},
            // Path Bottom Row (index 5-11)
            {x: 5.5, y: 8.5}, {x: 4.5, y: 8.5}, {x: 3.5, y: 8.5}, {x: 2.5, y: 8.5}, {x: 1.5, y: 8.5}, {x: 0.5, y: 8.5}, 
            // Left Column (index 12-13) - Corner
            {x: 0.5, y: 7.5},
            {x: 0.5, y: 6.5}, // 13 (Blue Start)
            // Blue Home Row to Path Start (index 14-18) - Left to Top
            {x: 1.5, y: 6.5}, {x: 2.5, y: 6.5}, {x: 3.5, y: 6.5}, {x: 4.5, y: 6.5}, {x: 5.5, y: 6.5},
            // Path Left Column (index 19-25)
            {x: 6.5, y: 5.5}, {x: 6.5, y: 4.5}, {x: 6.5, y: 3.5}, {x: 6.5, y: 2.5}, {x: 6.5, y: 1.5}, {x: 6.5, y: 0.5}, 
            // Top Row (index 26-27) - Corner
            {x: 7.5, y: 0.5},
            {x: 8.5, y: 0.5}, // 27 (Green Start)
            // Green Home Row to Path Start (index 28-32) - Top to Right
            {x: 8.5, y: 1.5}, {x: 8.5, y: 2.5}, {x: 8.5, y: 3.5}, {x: 8.5, y: 4.5}, {x: 8.5, y: 5.5},
            // Path Top Column (index 33-39)
            {x: 9.5, y: 6.5}, {x: 10.5, y: 6.5}, {x: 11.5, y: 6.5}, {x: 12.5, y: 6.5}, {x: 13.5, y: 6.5}, {x: 14.5, y: 6.5}, 
            // Right Column (index 40-41) - Corner
            {x: 14.5, y: 7.5},
            {x: 14.5, y: 8.5}, // 41 (Yellow Start)
            // Yellow Home Row to Path Start (index 42-46) - Right to Bottom
            {x: 13.5, y: 8.5}, {x: 12.5, y: 8.5}, {x: 11.5, y: 8.5}, {x: 10.5, y: 8.5}, {x: 9.5, y: 8.5},
            // Path Right Column (index 47-51)
            {x: 8.5, y: 9.5}, {x: 8.5, y: 10.5}, {x: 8.5, y: 11.5}, {x: 8.5, y: 12.5}, {x: 8.5, y: 13.5}, {x: 8.5, y: 14.5}, 
        ].slice(0, 52), // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³Ø§Ø± 52 Ø®Ù„ÙŠØ© ÙÙ‚Ø· (0-51)

        // Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø¨ÙŠØª (4 Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨) - ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù„ØªØ¨Ø¯Ùˆ 2x2 Ù…Ø±ØªØ¨Ø©
        HOME: [
            [{x: 2.5, y: 11.5}, {x: 4.5, y: 11.5}, {x: 2.5, y: 13.5}, {x: 4.5, y: 13.5}], // Red (0)
            [{x: 2.5, y: 1.5}, {x: 4.5, y: 1.5}, {x: 2.5, y: 3.5}, {x: 4.5, y: 3.5}],   // Blue (1)
            [{x: 10.5, y: 1.5}, {x: 12.5, y: 1.5}, {x: 10.5, y: 3.5}, {x: 12.5, y: 3.5}], // Green (2)
            [{x: 10.5, y: 11.5}, {x: 12.5, y: 11.5}, {x: 10.5, y: 13.5}, {x: 12.5, y: 13.5}], // Yellow (3) 
        ],
        // Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (6 Ø®Ø§Ù†Ø§Øª Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨)
        FINAL_PATH: [
            [{x: 7.5, y: 13.5}, {x: 7.5, y: 12.5}, {x: 7.5, y: 11.5}, {x: 7.5, y: 10.5}, {x: 7.5, y: 9.5}, {x: 7.5, y: 8.5}], // Red (0) - Vertical Up
            [{x: 1.5, y: 7.5}, {x: 2.5, y: 7.5}, {x: 3.5, y: 7.5}, {x: 4.5, y: 7.5}, {x: 5.5, y: 7.5}, {x: 6.5, y: 7.5}], // Blue (1) - Horizontal Right
            [{x: 7.5, y: 1.5}, {x: 7.5, y: 2.5}, {x: 7.5, y: 3.5}, {x: 7.5, y: 4.5}, {x: 7.5, y: 5.5}, {x: 7.5, y: 6.5}], // Green (2) - Vertical Down
            [{x: 13.5, y: 7.5}, {x: 12.5, y: 7.5}, {x: 11.5, y: 7.5}, {x: 10.5, y: 7.5}, {x: 9.5, y: 7.5}, {x: 8.5, y: 7.5}], // Yellow (3) - Horizontal Left
        ],
        // Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ
        GOAL: {x: 7.5, y: 7.5}
    };

    // ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª (0-15) Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨ÙƒØ³Ù„
    function toPixel(unit) {
        return unit * (CANVAS.width / 15);
    }

    //================================================================================
    // 2. ÙØ¦Ø© Ø§Ù„ØµÙˆØª (Base64 Audio Generation)
    //================================================================================

    class SoundManager {
        constructor() {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.muted = localStorage.getItem('ludoMuted') === 'true';
            this.buffers = {};
            this.loadSounds();
            document.getElementById('mute-button').textContent = this.muted ? 'ğŸ”‡' : 'ğŸ”Š';
        }

        async loadSounds() {
            // Ø¨ÙŠØ§Ù†Ø§Øª PCM Ø¨Ø³ÙŠØ·Ø© Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ø£ØµÙˆØ§Øª (Ù†ØºÙ…Ø§Øª Ù‚ØµÙŠØ±Ø©)
            const sounds = {
                DICE: [0.1, 800, 0.05, 1000, 0.05, 600, 0.05, 1200], // Ù…ØªØ°Ø¨Ø°Ø¨ ÙˆÙ‚ØµÙŠØ±
                MOVE: [0.08, 500], // Ù†ØºÙ…Ø© Ù‚ØµÙŠØ±Ø©
                CAPTURE: [0.1, 1500, 0.1, 300], // Ù†ØºÙ…ØªØ§Ù† Ø­Ø§Ø¯ØªØ§Ù†
                WIN: [0.2, 1200, 0.1, 1500, 0.3, 1800], // ØªØªØ§Ø¨Ø¹ Ù†ØºÙ…Ø§Øª Ø§Ø­ØªÙØ§Ù„ÙŠØ©
            };

            for (const key in sounds) {
                this.buffers[key] = this.createBuffer(sounds[key]);
            }
        }

        // Ø¥Ù†Ø´Ø§Ø¡ AudioBuffer Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª PCM Ù…Ø¨Ø³Ø·Ø© (Ø§Ù„Ø²Ù…Ù† Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠØŒ Ø§Ù„ØªØ±Ø¯Ø¯ Ø¨Ø§Ù„Ù‡Ø±ØªØ²)
        createBuffer(sequence) {
            const sampleRate = 44100;
            let totalDuration = 0;
            for (let i = 0; i < sequence.length; i += 2) {
                totalDuration += sequence[i];
            }

            const frameCount = sampleRate * totalDuration;
            const buffer = this.audioCtx.createBuffer(1, frameCount, sampleRate);
            const channel = buffer.getChannelData(0);

            let offset = 0;
            for (let i = 0; i < sequence.length; i += 2) {
                const duration = sequence[i];
                const frequency = sequence[i + 1];
                const segmentFrames = Math.floor(sampleRate * duration);

                for (let j = 0; j < segmentFrames; j++) {
                    const time = j / sampleRate;
                    // Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
                    channel[offset + j] = Math.sin(2 * Math.PI * frequency * time) * 0.5;
                }
                offset += segmentFrames;
            }
            return buffer;
        }

        play(key) {
            if (this.muted || !this.buffers[key]) return;

            const source = this.audioCtx.createBufferSource();
            source.buffer = this.buffers[key];
            source.connect(this.audioCtx.destination);
            source.start();
        }

        toggleMute() {
            this.muted = !this.muted;
            localStorage.setItem('ludoMuted', this.muted);
            document.getElementById('mute-button').textContent = this.muted ? 'ğŸ”‡' : 'ğŸ”Š';
        }
    }


    //================================================================================
    // 3. ÙØ¦Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© (Token, Player, GameState)
    //================================================================================

    class Token {
        constructor(id, playerId) {
            this.id = id;
            this.playerId = playerId;
            // 0-3: Home, 4-55: Path (4-55), 56-61: Final Path (56-61), 62: Goal
            this.position = this.id; // ÙŠØ¨Ø¯Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØª (0, 1, 2, 3)
            this.targetX = 0; 
            this.targetY = 0;
            this.isMoving = false;
            this.currentX = 0; 
            this.currentY = 0;
        }

        // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø®Ù„ÙŠØ© Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
        getCoords() {
            const playerIdx = this.playerId;
            let coords;

            if (this.position < 4) { // ÙÙŠ Ø§Ù„Ø¨ÙŠØª (0, 1, 2, 3)
                coords = BOARD_CONFIG.HOME[playerIdx][this.position];
            } else if (this.position < 56) { // ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (Ø§Ù„Ù…ÙˆØ§Ø¶Ø¹ 4 Ø¥Ù„Ù‰ 55)
                // 4 Ù‡ÙŠ Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨ÙŠØª (Ø¨Ø¯Ø§ÙŠØ© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø·ÙˆØ§Øª)
                const playerStartIdx = START_POSITIONS[playerIdx]; // 0, 13, 26, 39
                const stepsFromStart = this.position - 4;
                const pathIndex = (playerStartIdx + stepsFromStart) % 52; // Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (0-51)
                coords = BOARD_CONFIG.PATH[pathIndex];
            } else if (this.position < 62) { // ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (56 Ø¥Ù„Ù‰ 61)
                const finalPathIndex = this.position - 56;
                coords = BOARD_CONFIG.FINAL_PATH[playerIdx][finalPathIndex];
            } else { // ÙÙŠ Ø§Ù„Ù‡Ø¯Ù (62)
                coords = BOARD_CONFIG.GOAL;
            }

            return { x: toPixel(coords.x), y: toPixel(coords.y) };
        }
    }

    class Player {
        constructor(id, type, aiLevel = 'EASY') {
            this.id = id;
            this.color = PLAYER_COLORS[id].color;
            this.name = ARABIC_TEXT.PLAYER + (id + 1) + ' (' + PLAYER_COLORS[id].name + ')';
            this.type = type; // 'HUMAN' or 'AI'
            this.aiLevel = aiLevel; // 'EASY', 'MEDIUM', 'HARD'
            this.tokens = [new Token(0, id), new Token(1, id), new Token(2, id), new Token(3, id)];
        }
    }

    class LudoGame {
        constructor() {
            this.players = [];
            this.currentPlayerIdx = 0;
            this.diceValue = 0;
            this.hasExtraTurn = false;
            this.sixStreak = 0;
            this.isRolling = false;
            this.isAnimating = false;
            this.winner = null;
            this.activePlayers = []; 
            this.validMoves = {}; 
            this.selectedToken = null;
            this.sm = new SoundManager();
        }

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…Ø®ØªØ§Ø±ÙŠÙ†
        setupGame(playerConfigs) {
            this.players = [];
            this.activePlayers = [];
            this.currentPlayerIdx = 0;
            this.sixStreak = 0;
            this.winner = null;

            playerConfigs.forEach((config, id) => {
                const player = new Player(id, config.type, config.aiLevel);
                this.players.push(player);
                this.activePlayers.push(id);
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙŠØª
                player.tokens.forEach((token, i) => token.position = i);
            });
            this.updateStatus(ARABIC_TEXT.START_NEW);
            this.diceValue = 0; 
            this.nextTurn();
            this.saveGame();
            this.renderer.render(); 
        }

        // ØªØ­Ù…ÙŠÙ„ Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ù† localStorage
        loadGame(state) {
            this.activePlayers = state.activePlayers;
            this.players = state.players.map(pState => {
                const player = new Player(pState.id, pState.type, pState.aiLevel);
                player.tokens = pState.tokens.map(tState => {
                    const token = new Token(tState.id, tState.playerId);
                    token.position = tState.position;
                    return token;
                });
                return player;
            });
            this.currentPlayerIdx = state.currentPlayerIdx;
            this.diceValue = state.diceValue;
            this.sixStreak = state.sixStreak || 0;
            this.winner = state.winner;
            this.hasExtraTurn = state.hasExtraTurn || false;
            this.updateStatus(ARABIC_TEXT.GAME_SAVED);

            // Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø­Ø±ÙƒØ© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¯ÙˆØ± AI
            if (this.isAIPlayer(this.currentPlayerIdx) && !this.winner) {
                this.handleAI();
            } else if (!this.winner) {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù‚ÙŠÙ…Ø© Ù†Ø±Ø¯ Ù…Ø­ÙÙˆØ¸Ø©ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
                if (this.diceValue !== 0) {
                     this.validMoves = this.getValidMoves(this.diceValue);
                }
                this.updateRollButton();
                this.renderer.highlightValidMoves(this.validMoves);
            }
        }

        saveGame() {
            const state = {
                players: this.players.map(p => ({
                    id: p.id,
                    type: p.type,
                    aiLevel: p.aiLevel,
                    tokens: p.tokens.map(t => ({
                        id: t.id,
                        playerId: t.playerId,
                        position: t.position
                    }))
                })),
                currentPlayerIdx: this.currentPlayerIdx,
                diceValue: this.diceValue,
                sixStreak: this.sixStreak,
                hasExtraTurn: this.hasExtraTurn,
                activePlayers: this.activePlayers,
                winner: this.winner
            };
            localStorage.setItem('ludoState', JSON.stringify(state));
            document.getElementById('resume-game').style.display = localStorage.getItem('ludoState') ? 'inline-block' : 'none';
        }

        // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„ØªØ§Ù„ÙŠ
        nextPlayer() {
            let nextIndex = (this.activePlayers.indexOf(this.currentPlayerIdx) + 1) % this.activePlayers.length;
            this.currentPlayerIdx = this.activePlayers[nextIndex];
            this.sixStreak = 0;
            this.hasExtraTurn = false;
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„ØªØ§Ù„ÙŠ
        nextTurn() {
            if (this.winner) {
                this.showWinModal(this.winner);
                return;
            }

            if (!this.hasExtraTurn || this.diceValue === 0) {
                this.nextPlayer();
            }

            this.diceValue = 0;
            this.renderer.highlightValidMoves({});
            this.selectedToken = null;
            this.updateRollButton();
            this.renderer.drawDiceValue(this.diceValue); 

            // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ
            this.renderer.updateCurrentPlayerIndicator(this.currentPlayerIdx);


            if (this.isAIPlayer(this.currentPlayerIdx)) {
                this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name);
                setTimeout(() => this.rollDice(), 1000);
            } else {
                this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLL_DICE);
            }
        }

        isAIPlayer(id) {
            if (!this.players[id]) return false; 
            return this.players[id].type === 'AI';
        }

        // Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯
        rollDice() {
            if (this.isRolling || this.isAnimating || this.diceValue !== 0) return;

            this.sm.play('DICE');
            this.isRolling = true;
            this.updateRollButton(); 

            const diceDisplay = document.getElementById('dice-display');
            diceDisplay.classList.add('rolling');

            let rollCount = 0;
            const maxRolls = 20; 
            const rollInterval = setInterval(() => {
                rollCount++;
                this.diceValue = Math.floor(Math.random() * 6) + 1;
                this.renderer.drawDiceValue(this.diceValue); 

                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    diceDisplay.classList.remove('rolling');
                    this.isRolling = false;
                    this.afterDiceRoll();
                }
            }, 50); 
        }

        // Ù…Ø§ Ø¨Ø¹Ø¯ Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯
        afterDiceRoll() {
            this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLLED + this.diceValue);

            const isSix = this.diceValue === 6;

            if (isSix) {
                this.sixStreak++;
                if (this.sixStreak === 3) {
                    this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - 3 Ø³ØªØ§Øª Ù…ØªØªØ§Ù„ÙŠØ©ØŒ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¯ÙˆØ±!');
                    setTimeout(() => {
                        this.sixStreak = 0;
                        this.hasExtraTurn = false; 
                        this.diceValue = 0; 
                        this.nextTurn();
                    }, 1500);
                    return;
                } else {
                    this.hasExtraTurn = true;
                    this.updateStatus(ARABIC_TEXT.CURRENT_TURN + this.players[this.currentPlayerIdx].name + ' - ' + ARABIC_TEXT.ROLLED + this.diceValue + ' - ' + ARABIC_TEXT.EXTRA_TURN);
                }
            } else {
                this.hasExtraTurn = false;
                this.sixStreak = 0;
            }

            this.validMoves = this.getValidMoves(this.diceValue);
            this.renderer.highlightValidMoves(this.validMoves);

            if (Object.keys(this.validMoves).length === 0) {
                // Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª ØµØ§Ù„Ø­Ø©
                this.updateStatus(ARABIC_TEXT.NO_MOVES);
                this.diceValue = 0; 
                setTimeout(() => this.nextTurn(), 1500);
            } else if (this.isAIPlayer(this.currentPlayerIdx)) {
                this.handleAI();
            } else {
                this.updateRollButton();
            }
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¯ÙˆØ± Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        handleAI() {
            const ai = new AI(this);
            const player = this.players[this.currentPlayerIdx];
            const bestMove = ai.chooseBestMove(player.aiLevel, this.diceValue, this.validMoves);

            if (bestMove) {
                const token = player.tokens.find(t => t.id === bestMove.tokenId);
                setTimeout(() => this.moveToken(token, bestMove.targetPosition), 1500);
            } else {
                setTimeout(() => this.nextTurn(), 1500);
            }
        }

        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ØµØ§Ù„Ø­Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹
        getValidMoves(dice) {
            const validMoves = {};
            const player = this.players[this.currentPlayerIdx];

            if (dice === 0) return {};

            player.tokens.forEach(token => {
                let targetPos = -1;

                if (token.position < 4) { // ÙÙŠ Ø§Ù„Ø¨ÙŠØª (0, 1, 2, 3)
                    if (dice === 6) {
                        targetPos = 4; // Ø§Ù„Ø®Ø§Ù†Ø© 4 ØªÙ…Ø«Ù„ Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨ÙŠØª
                    }
                } else if (token.position < 56) { // ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (4 Ø¥Ù„Ù‰ 55)

                    const stepsToFinalPath = 56 - token.position; 

                    if (dice < stepsToFinalPath) {
                        targetPos = token.position + dice;
                    } else if (dice >= stepsToFinalPath) {
                        const finalPathIndex = dice - stepsToFinalPath;
                        if (finalPathIndex <= 6) { // 6 Ø®Ø§Ù†Ø§Øª ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† + Ø§Ù„Ù‡Ø¯Ù
                            targetPos = 56 + finalPathIndex; // 56 Ø¥Ù„Ù‰ 62
                        }
                    }
                } else if (token.position >= 56 && token.position < 62) { // ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (56 Ø¥Ù„Ù‰ 61)
                    targetPos = token.position + dice;

                    if (targetPos > 62) {
                         targetPos = -1; // Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù‡Ø¯Ù (62)
                    }
                }

                if (token.position === 62) {
                    targetPos = -1;
                }

                if (targetPos !== -1) {
                    validMoves[token.id] = targetPos;
                }
            });
            return validMoves;
        }

        // ØªÙ†ÙÙŠØ° Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ø·Ø¹Ø©
        moveToken(token, targetPosition) {
            if (this.isAnimating) return;

            this.isAnimating = true;
            this.renderer.highlightValidMoves({}); 

            this.updateRollButton(); 

            this.renderer.startTokenAnimation(token, targetPosition, () => {
                this.isAnimating = false;
                this.sm.play('MOVE');

                const oldPosition = token.position;
                token.position = targetPosition; 

                if (targetPosition >= 4 && targetPosition < 56) {
                    this.checkCapture(token, targetPosition);
                }

                this.saveGame();

                this.checkWin(token.playerId);

                this.diceValue = 0; 
                this.nextTurn();
            });
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
        checkCapture(movingToken, targetPosition) {
            const pathIndex = this.convertToGlobalPathIndex(movingToken.playerId, targetPosition);
            const isSafeSpot = this.isGlobalSafeSpot(pathIndex);

            if (isSafeSpot) return;

            this.players.forEach(player => {
                if (player.id !== movingToken.playerId) {
                    player.tokens.forEach(opponentToken => {
                        if (opponentToken.position < 4 || opponentToken.position >= 56) return;

                        const opponentPathPos = this.convertToGlobalPathIndex(opponentToken.playerId, opponentToken.position);

                        if (pathIndex === opponentPathPos) {
                            opponentToken.position = opponentToken.id;
                            this.sm.play('CAPTURE');
                            this.updateStatus(this.players[movingToken.playerId].name + ' Ø¶Ø±Ø¨ Ù‚Ø·Ø¹Ø© Ù„Ù€ ' + player.name);
                        }
                    });
                }
            });
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© (4-55) Ø¥Ù„Ù‰ Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (0-51)
        convertToGlobalPathIndex(playerId, position) {
             const playerStartIdx = START_POSITIONS[playerId];
             const stepsFromStart = position - 4;
             return (playerStartIdx + stepsFromStart) % 52;
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù…Ø¹Ø±ÙØ© Ù‡Ù„ Ø§Ù„Ø®Ø§Ù†Ø© Ø¢Ù…Ù†Ø©
        isGlobalSafeSpot(pathIndex) {
            return SAFE_SPOTS.includes(pathIndex);
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
        checkWin(playerId) {
            const player = this.players[playerId];
            const allTokensInGoal = player.tokens.every(token => token.position === 62);
            if (allTokensInGoal) {
                this.winner = playerId;
                this.showWinModal(playerId);
                localStorage.removeItem('ludoState'); 
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø±Ø¶ (Ø§Ù„Ù†ØµÙˆØµ)
        updateStatus(message) {
            document.getElementById('status-display').textContent = message;
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø²Ø± Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯
        updateRollButton() {
            const diceDisplay = document.getElementById('dice-display');
            const currentPlayer = this.players[this.currentPlayerIdx];

            diceDisplay.classList.remove('disabled');

            if (this.winner || currentPlayer.type === 'AI' || this.isRolling || this.isAnimating || this.diceValue !== 0) {
                diceDisplay.classList.add('disabled');
            } else if (this.diceValue === 0) {

            }
        }


        showWinModal(winnerId) {
            const winnerName = this.players[winnerId].name;
            document.getElementById('winner-message').textContent = ARABIC_TEXT.WINNER_IS + winnerName;
            document.getElementById('win-modal').classList.add('active');
            this.sm.play('WIN');
            this.renderer.render(); 
        }

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚Ø·Ø¹Ø© Ù„Ù„Ù†Ù‚Ù„
        selectToken(token) {
            if (this.isAIPlayer(this.currentPlayerIdx) || this.isRolling || this.isAnimating || this.diceValue === 0 || this.winner) return;
            if (token.playerId !== this.currentPlayerIdx) return; 

            const targetPos = this.validMoves[token.id];

            if (targetPos !== undefined) {
                this.selectedToken = token;
                this.moveToken(token, targetPos);
            }
        }
    }


    //================================================================================
    // 4. ÙØ¦Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (AI)
    //================================================================================

    class AI {
        constructor(game) {
            this.game = game;
            this.playerId = game.currentPlayerIdx;
            this.player = game.players[this.playerId];
            this.opponentTokens = this.getOpponentTokens();
        }

        getOpponentTokens() {
            return this.game.players
                .filter(p => p.id !== this.playerId)
                .flatMap(p => p.tokens)
                .filter(t => t.position >= 4 && t.position < 56);
        }

        // Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
        chooseBestMove(level, diceValue, validMoves) {
            const moves = Object.entries(validMoves).map(([tokenId, targetPosition]) => ({
                tokenId: parseInt(tokenId),
                targetPosition: targetPosition
            }));

            if (moves.length === 0) return null;

            if (level === 'EASY') {
                return this.easyMove(moves, diceValue);
            } else if (level === 'MEDIUM') {
                return this.mediumMove(moves, diceValue);
            } else { // HARD
                return this.hardMove(moves, diceValue);
            }
        }

        // Ø³Ù‡Ù„: ÙŠØ¯Ø®Ù„ Ø¨Ø§Ù„Ù€ 6ØŒ ÙŠØ­Ø±Ùƒ Ø£ÙˆÙ„ Ù‚Ø·Ø¹Ø© Ù…ØªØ§Ø­Ø© (Ø§Ù„Ø£Ù‚Ù„ ID)
        easyMove(moves, diceValue) {
            if (diceValue === 6) {
                const homeMove = moves.find(m => this.player.tokens.find(t => t.id === m.tokenId).position < 4);
                if (homeMove) return homeMove;
            }
            return moves[0];
        }

        // Ù…ØªÙˆØ³Ø·: ÙŠÙØ¶Ù‘Ù„ Ø§Ù„Ø¶Ø±Ø¨ØŒ ÙŠØªØ¬Ù†Ø¨ Ø§Ù„Ø®Ø·Ø±ØŒ ÙŠÙˆØ²Ø¹ Ø§Ù„ØªÙ‚Ø¯Ù…
        mediumMove(moves, diceValue) {
            let bestMove = null;
            let maxScore = -Infinity;

            for (const move of moves) {
                const score = this.evaluateMove(move.tokenId, move.targetPosition, diceValue, 'MEDIUM');
                if (score > maxScore) {
                    maxScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // ØµØ¹Ø¨: ØªÙ‚ÙŠÙŠÙ… Ù†Ù‚Ø§Ø· Ù…ØªÙˆØ§Ø²Ù† (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ù„Ù„Ø¶Ø±Ø¨ØŒ Ø§Ù„ØªÙ‚Ø¯Ù… Ø§Ù„Ø¢Ù…Ù†ØŒ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø£Ù‚Ø±Ø¨ Ù„Ù„Ù‡Ø¯Ù)
        hardMove(moves, diceValue) {
            let bestMove = null;
            let maxScore = -Infinity;

            for (const move of moves) {
                const score = this.evaluateMove(move.tokenId, move.targetPosition, diceValue, 'HARD');
                if (score > maxScore) {
                    maxScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // Ø¯Ø§Ù„Ø© ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø­Ø±ÙƒØ©
        evaluateMove(tokenId, targetPosition, diceValue, level) {
            let score = 0;
            const token = this.player.tokens.find(t => t.id === tokenId);

            // 1. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¶Ø±Ø¨/Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… (Capture)
            const capturedToken = this.isCaptureMove(targetPosition, token.playerId);
            if (capturedToken) {
                score += 100; 
            }

            // 2. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù (Goal)
            if (targetPosition === 62) {
                score += 500; 
            }

            // 3. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¨ÙŠØª
            if (token.position < 4 && targetPosition === 4) {
                score += 50;
            }

            // 4. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªÙ‚Ø¯Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© (Ø£Ù‚Ù„ Ù‚ÙŠÙ…Ø© Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© = Ø£Ù‚Ø±Ø¨ Ù„Ù„Ù‡Ø¯Ù)
            score += (62 - targetPosition) * -2;

            // 5. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ù…Ø§Ù† (Threat Avoidance)
            if (targetPosition >= 4 && targetPosition < 56) {
                const pathIndex = this.convertToGlobalPathIndex(token.playerId, targetPosition);
                const isSafe = this.isGlobalSafeSpot(pathIndex);

                if (!isSafe) {
                    const threats = this.getThreats(pathIndex);
                    if (threats.length > 0) {
                        score -= 80; 
                    }
                }
            }

            // 6. Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ
            if (targetPosition >= 56 && token.position < 56) {
                 score += 70;
            }

            // 7. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø®Ø·Ø± (ÙÙ‚Ø· Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹Ø¨)
            if (level === 'HARD') {
                if (targetPosition >= 4 && targetPosition < 56) {
                    const isSafe = this.isGlobalSafeSpot(this.convertToGlobalPathIndex(token.playerId, targetPosition));
                    if (!isSafe) {
                        const nextTurnThreats = this.getFutureThreats(targetPosition);
                        if (nextTurnThreats.length > 0) {
                            score -= 150; 
                        }
                    }
                }
            }

            return score;
        }

        // ØªØ­ÙˆÙŠÙ„ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© (4-55) Ø¥Ù„Ù‰ Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±Ùƒ (0-51)
        convertToGlobalPathIndex(playerId, position) {
            const playerStartIdx = START_POSITIONS[playerId];
            const stepsFromStart = position - 4;
            return (playerStartIdx + stepsFromStart) % 52;
        }

        // Ù‡Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§Ù†Ø© Ø¢Ù…Ù†Ø©ØŸ
        isGlobalSafeSpot(pathIndex) {
            return SAFE_SPOTS.includes(pathIndex);
        }

        // Ù‡Ù„ Ù‡Ù†Ø§Ùƒ Ù‚Ø·Ø¹Ø© Ø®ØµÙ… ÙŠÙ…ÙƒÙ† Ø¶Ø±Ø¨Ù‡Ø§ ÙÙŠ targetPositionØŸ
        isCaptureMove(targetPosition, movingPlayerId) {
            if (targetPosition < 4 || targetPosition >= 56) return null; 

            const pathIndex = this.convertToGlobalPathIndex(movingPlayerId, targetPosition);
            if (this.isGlobalSafeSpot(pathIndex)) return null; 

            return this.opponentTokens.find(t => {
                const opponentPathIndex = this.convertToGlobalPathIndex(t.playerId, t.position);
                return pathIndex === opponentPathIndex;
            });
        }

        // Ø¬Ù„Ø¨ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ù‚Ø·Ø¹ Ø§Ù„Ø®ØµÙ… Ø§Ù„ÙˆØ§Ù‚ÙØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ù†Ø©)
        getThreats(pathIndex) {
            return this.opponentTokens.filter(t => {
                const opponentPathIndex = this.convertToGlobalPathIndex(t.playerId, t.position);
                return pathIndex === opponentPathIndex;
            });
        }

        // Ø¬Ù„Ø¨ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©: Ù‡Ù„ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø®ØµÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ targetPosition ÙÙŠ Ø¯ÙˆØ± Ù‚Ø§Ø¯Ù…ØŸ
        getFutureThreats(targetPosition) {
            const targetPathIndex = this.convertToGlobalPathIndex(this.playerId, targetPosition);
            let threats = [];

            for (const opponentToken of this.opponentTokens) {
                const opponentPlayerId = opponentToken.playerId;
                const opponentGlobalPos = this.convertToGlobalPathIndex(opponentPlayerId, opponentToken.position);

                const distance = (targetPathIndex - opponentGlobalPos + 52) % 52; 

                if (distance >= 1 && distance <= 6) {
                    threats.push(opponentToken);
                }
            }
            return threats;
        }
    }


    //================================================================================
    // 5. ÙØ¦Ø© Ø§Ù„Ø±Ø³Ø§Ù… (Renderer)
    //================================================================================

    class Renderer {
        constructor(game) {
            this.game = game;
            this.cellSize = 0;
            this.tokenRadius = 0;
            this.highlightedMoves = {};
            this.activeAnimation = null;
            this.resizeCanvas();
            window.addEventListener('resize', this.resizeCanvas.bind(this));
            CANVAS.addEventListener('click', this.handleCanvasClick.bind(this));
            CANVAS.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = CANVAS.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                this.handleClick(x, y);
            });
            // Ø±Ø¨Ø· Ø§Ù„Ù†Ø±Ø¯ Ø¨Ø§Ù„Ù†Ù‚Ø±
            document.getElementById('dice-display').addEventListener('click', () => {
                if (!document.getElementById('dice-display').classList.contains('disabled')) {
                    this.game.rollDice();
                }
            });
        }

        resizeCanvas() {
            const containerWidth = document.getElementById('game-container').clientWidth - 40; 
            CANVAS.width = containerWidth;
            CANVAS.height = containerWidth;
            this.cellSize = CANVAS.width / 15;
            this.tokenRadius = this.cellSize * 0.35; // ØªØµØºÙŠØ± Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø± Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„ØªØ¬Ù…ÙŠØ¹
            this.game.renderer = this; 
            this.render();
        }

        // Ø±Ø³Ù… Ø§Ù„Ù„ÙˆØ­Ø© ÙƒØ§Ù…Ù„Ø©
        render() {
            CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
            this.drawBoardStructure();
            if (this.game.players.length) {
                 this.drawTokens();
            }
        }

        drawBoardStructure() {
            const cs = this.cellSize;
            const colors = PLAYER_COLORS;

            // 1. Ø±Ø³Ù… Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø®Ù„ÙÙŠØ©
            CTX.fillStyle = '#f7f7f7'; 
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // 2. Ø±Ø³Ù… Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø¨ÙŠÙˆØª (Corners) 6x6
            const homeCoords = [
                {x: 9, y: 9, c: 0}, // Red (Bottom Right)
                {x: 0, y: 0, c: 1}, // Blue (Top Left)
                {x: 9, y: 0, c: 2}, // Green (Top Right)
                {x: 0, y: 9, c: 3}  // Yellow (Bottom Left)
            ];

            homeCoords.forEach(h => {
                CTX.fillStyle = colors[h.c].light;
                CTX.fillRect(h.x * cs, h.y * cs, 6 * cs, 6 * cs);
                CTX.strokeStyle = '#333';
                CTX.lineWidth = 2;
                CTX.strokeRect(h.x * cs, h.y * cs, 6 * cs, 6 * cs);
            });


            // 3. Ø±Ø³Ù… Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ (Ø§Ù„Ø­Ø¯ÙˆØ¯ ÙˆØ§Ù„ØªÙ„ÙˆÙŠÙ†)
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const isHorizontalTrack = (j >= 6 && j <= 8);
                    const isVerticalTrack = (i >= 6 && i <= 8);
                    const isTrack = isHorizontalTrack || isVerticalTrack;
                    const isCorner = (i < 6 && j < 6) || (i >= 9 && j < 6) || (i < 6 && j >= 9) || (i >= 9 && j >= 9);

                    if (isTrack && !isCorner) {
                         // Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (Ù…Ù„ÙˆÙ† Ø¨Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨)
                        let isFinalPath = false;
                        let playerIdx = -1;
                        if (i === 7 && j >= 9 && j <= 13) { playerIdx = 0; isFinalPath = true; } // Red 
                        else if (j === 7 && i >= 1 && i <= 5) { playerIdx = 1; isFinalPath = true; } // Blue 
                        else if (i === 7 && j >= 1 && j <= 5) { playerIdx = 2; isFinalPath = true; } // Green 
                        else if (j === 7 && i >= 9 && i <= 13) { playerIdx = 3; isFinalPath = true; } // Yellow 

                        if (isFinalPath) {
                            CTX.fillStyle = colors[playerIdx].color;
                        } else {
                            CTX.fillStyle = '#fff';
                        }

                        CTX.fillRect(i * cs, j * cs, cs, cs);
                        CTX.strokeStyle = '#333';
                        CTX.lineWidth = 1;
                        CTX.strokeRect(i * cs, j * cs, cs, cs);
                    }
                }
            }

            // 4. Ø±Ø³Ù… Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ (Goal - Ø¨Ø´ÙƒÙ„ Ù…Ø«Ù„Ø«Ø§Øª Ù…Ù„ÙˆÙ†Ø©)
            this.drawGoalTriangle(7.5, 6, 9, 7.5, 7.5, 7.5, colors[2].color); // Green Top
            this.drawGoalTriangle(7.5, 9, 6, 7.5, 7.5, 7.5, colors[0].color); // Red Bottom
            this.drawGoalTriangle(6, 7.5, 7.5, 6, 7.5, 7.5, colors[1].color); // Blue Left
            this.drawGoalTriangle(9, 7.5, 7.5, 9, 7.5, 7.5, colors[3].color); // Yellow Right

            // Ø±Ø³Ù… Ù†Ø¬Ù…Ø© Ø§Ù„Ù…Ø±ÙƒØ²
            CTX.fillStyle = '#fff'; 
            CTX.font = `${cs * 0.9}px Arial`;
            CTX.fillText('â˜…', toPixel(7.5), toPixel(7.5) + 3);


            // 5. Ø±Ø³Ù… Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠÙˆØª (4 Ø¯ÙˆØ§Ø¦Ø± Ø¯Ø§Ø®Ù„ÙŠØ© 2x2)
            for (let i = 0; i < 4; i++) {
                const homeCoords = BOARD_CONFIG.HOME[i];
                CTX.strokeStyle = colors[i].color; // Ù„ÙˆÙ† Ø§Ù„Ø­Ø¯ Ù‡Ùˆ Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨
                CTX.lineWidth = 4;
                homeCoords.forEach(c => {
                    CTX.beginPath();
                    // Ø¯Ø§Ø¦Ø±Ø© ÙƒØ¨ÙŠØ±Ø© Ù„ØªØ­Ø¯ÙŠØ¯ Ù…ÙƒØ§Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØª
                    CTX.arc(toPixel(c.x), toPixel(c.y), cs * 1.0, 0, 2 * Math.PI); 
                    CTX.fillStyle = colors[i].light;
                    CTX.fill();
                    CTX.stroke();

                    // Ø¯Ø§Ø¦Ø±Ø© Ø£ØµØºØ± Ù„ØªØ­Ø¯ÙŠØ¯ Ù…ÙƒØ§Ù† Ø§Ù„Ù‚Ø·Ø¹Ø©
                    CTX.beginPath();
                    CTX.arc(toPixel(c.x), toPixel(c.y), this.tokenRadius * 1.5, 0, 2 * Math.PI);
                    CTX.strokeStyle = colors[i].color;
                    CTX.lineWidth = 2;
                    CTX.stroke();
                });
            }


            // 6. ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ø¢Ù…Ù†Ø© (Ø§Ù„Ù†Ø¬Ù…Ø©)
            CTX.textAlign = 'center';
            CTX.textBaseline = 'middle';
            CTX.font = `${cs * 0.7}px Arial`;

            SAFE_SPOTS.forEach(index => {
                const coords = BOARD_CONFIG.PATH[index];

                // ØªÙ„ÙˆÙŠÙ† Ø®Ø§Ù†Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø¨Ù„ÙˆÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨
                if (START_SPOTS.includes(index)) {
                     const playerIdx = START_SPOTS.indexOf(index);
                     CTX.fillStyle = colors[playerIdx].color;
                } else {
                     CTX.fillStyle = '#fff';
                }

                // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ù„ÙÙŠØ© Ù„Ù„Ø®Ø§Ù†Ø© Ù„ØªÙƒÙˆÙ† Ù…Ù„ÙˆÙ†Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
                CTX.fillRect(coords.x * cs - cs / 2, coords.y * cs - cs / 2, cs, cs);
                CTX.strokeStyle = '#333';
                CTX.lineWidth = 1;
                CTX.strokeRect(coords.x * cs - cs / 2, coords.y * cs - cs / 2, cs, cs);

                // Ø±Ø³Ù… Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø£Ù…Ø§Ù† (Ù†Ø¬Ù…Ø©)
                CTX.fillStyle = 'white';
                if (!START_SPOTS.includes(index)) {
                    CTX.fillStyle = '#000'; // Ø§Ù„Ù†Ø¬Ù…Ø© Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡
                }
                CTX.fillText('â˜…', toPixel(coords.x), toPixel(coords.y) + 2);
            });

            this.highlightValidMoves(this.highlightedMoves, false); 
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø±Ø³Ù… Ù…Ø«Ù„Ø«Ø§Øª Ø§Ù„Ù‡Ø¯Ù
        drawGoalTriangle(x1, y1, x2, y2, x3, y3, color) {
            const cs = this.cellSize;
            CTX.fillStyle = color;
            CTX.beginPath();
            CTX.moveTo(x1 * cs, y1 * cs);
            CTX.lineTo(x2 * cs, y2 * cs);
            CTX.lineTo(x3 * cs, y3 * cs);
            CTX.closePath();
            CTX.fill();
            CTX.strokeStyle = '#333';
            CTX.lineWidth = 2;
            CTX.stroke();
        }

        highlightValidMoves(moves, redraw = true) {
            this.highlightedMoves = moves;

            if (redraw) {
                this.render();
            }

            if (Object.keys(moves).length === 0) return;

            const targetPositions = Object.values(moves);
            const cs = this.cellSize;

            const uniqueTargets = [...new Set(targetPositions)];

            uniqueTargets.forEach(pos => {
                let coords;
                const tokenAtTarget = new Token(0, this.game.currentPlayerIdx);
                tokenAtTarget.position = pos;
                coords = tokenAtTarget.getCoords();

                // Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© ØªØ¸Ù„ÙŠÙ„ Ø­ÙˆÙ„ Ø§Ù„Ø®Ø§Ù†Ø©
                CTX.strokeStyle = '#FFD700'; // Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ Ù„Ø§ÙØª
                CTX.lineWidth = 5;
                CTX.beginPath();
                CTX.arc(coords.x, coords.y, cs * 0.48, 0, 2 * Math.PI);
                CTX.stroke();
            });
        }

        // Ø±Ø³Ù… Ø§Ù„Ù‚Ø·Ø¹
        drawTokens() {
            this.game.players.forEach(player => {
                // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹ Ø­Ø³Ø¨ Ø§Ù„Ø®Ø§Ù†Ø©
                const spots = {};
                player.tokens.forEach(token => {
                    const key = token.position;
                    if (!spots[key]) spots[key] = [];
                    spots[key].push(token);
                });

                // Ø±Ø³Ù… ÙƒÙ„ Ù‚Ø·Ø¹Ø©
                player.tokens.forEach(token => {
                    let { x, y } = token.getCoords();

                    if (token.isMoving) {
                        x = token.currentX;
                        y = token.currentY;
                    }

                    // Ù…Ù†Ø·Ù‚ ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹ (Stacking)
                    const tokensAtSameSpot = spots[token.position] || [];
                    if (tokensAtSameSpot.length > 1) {
                         const index = tokensAtSameSpot.indexOf(token);
                         const offsetAngle = (2 * Math.PI / tokensAtSameSpot.length) * index;
                         const offsetDistance = this.tokenRadius * 0.5;

                         // Ø¥Ø²Ø§Ø­Ø© Ø®ÙÙŠÙØ© Ù„Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…ÙˆØ¶Ø¹
                         if (token.position >= 4 && token.position < 62) {
                              x += Math.cos(offsetAngle) * offsetDistance;
                              y += Math.sin(offsetAngle) * offsetDistance;
                         } else if (token.position < 4) {
                             // Ø¥Ø²Ø§Ø­Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠØª Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„ Ø§Ù„ÙƒØ§Ù…Ù„ (Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ø¨ÙŠØª ØªÙ… ØªØ±ØªÙŠØ¨Ù‡Ø§ Ù…Ø³Ø¨Ù‚Ø§Ù‹)
                             const homeOffset = this.tokenRadius * 0.3;
                             if (index === 0) { x -= homeOffset; y -= homeOffset; }
                             if (index === 1) { x += homeOffset; y -= homeOffset; }
                             if (index === 2) { x -= homeOffset; y += homeOffset; }
                             if (index === 3) { x += homeOffset; y += homeOffset; }
                         }
                    }

                    CTX.fillStyle = player.color;
                    CTX.strokeStyle = '#fff'; // Ø­Ø¯ÙˆØ¯ Ø¨ÙŠØ¶Ø§Ø¡ ÙˆØ§Ø¶Ø­Ø©
                    CTX.lineWidth = 3;

                    // Ø§Ù„Ø¸Ù„
                    CTX.shadowColor = 'rgba(0,0,0,0.6)'; 
                    CTX.shadowBlur = 6;
                    CTX.shadowOffsetX = 2;
                    CTX.shadowOffsetY = 2;

                    // Ø¬Ø³Ù… Ø§Ù„Ù‚Ø·Ø¹Ø© (Ø¯Ø§Ø¦Ø±Ø©)
                    CTX.beginPath();
                    CTX.arc(x, y, this.tokenRadius, 0, 2 * Math.PI);
                    CTX.fill();
                    CTX.stroke();

                    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¸Ù„ Ù„Ù„Ø±Ø³Ù… Ø§Ù„ØªØ§Ù„ÙŠ
                    CTX.shadowBlur = 0;
                    CTX.shadowOffsetX = 0;
                    CTX.shadowOffsetY = 0;

                    // ØªØ£Ø«ÙŠØ± Ø§Ù„Ù„Ù…Ø¹Ø§Ù†
                    CTX.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    CTX.beginPath();
                    CTX.arc(x - this.tokenRadius * 0.3, y - this.tokenRadius * 0.3, this.tokenRadius * 0.3, 0, 2 * Math.PI);
                    CTX.fill();

                    // Ø±Ù‚Ù… Ø§Ù„Ù‚Ø·Ø¹Ø©
                    CTX.fillStyle = '#fff';
                    CTX.font = `${this.tokenRadius * 0.8}px Cairo, sans-serif`;
                    CTX.fillText((token.id + 1), x, y + 2);
                });
            });
        }

        // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ (Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© ÙˆØ§Ù„Ù†Ø±Ø¯)
        updateCurrentPlayerIndicator(playerId) {
            const statusDisplay = document.getElementById('status-display');
            const diceDisplay = document.getElementById('dice-display');

            // 1. ØªÙ„ÙˆÙŠÙ† Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø©
            statusDisplay.className = '';
            statusDisplay.classList.add(`player-turn-${playerId}`);

            // 2. ØªÙØ¹ÙŠÙ„ Ù…Ø¤Ø´Ø± Ø§Ù„Ø³Ù‡Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø±Ø¯
            diceDisplay.classList.remove('turn-0', 'turn-1', 'turn-2', 'turn-3');
            diceDisplay.classList.add(`turn-${playerId}`);
        }

        // Ø±Ø³Ù… Ù‚ÙŠÙ…Ø© Ø§Ù„Ù†Ø±Ø¯
        drawDiceValue(value) {
            document.getElementById('dice-display').textContent = value === 0 ? 'ğŸ²' : value;
        }

        // Ø¨Ø¯Ø¡ Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø³Ù„Ø³Ø© (Tweening)
        startTokenAnimation(token, targetPosition, callback) {
            token.isMoving = true;
            token.currentX = token.getCoords().x;
            token.currentY = token.getCoords().y;

            const startPos = token.position;
            const path = this.getAnimationPath(token.playerId, startPos, targetPosition);

            if (path.length === 0) {
                token.isMoving = false;
                callback();
                return;
            }

            let pathIndex = 0;
            const animationDuration = 120; // ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø­Ø±ÙƒØ©
            let startTime = null;
            let currentPathStep = path[0];

            const step = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;

                if (elapsed < animationDuration) {
                    const progress = elapsed / animationDuration;
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3); 

                    token.currentX = currentPathStep.startX + (currentPathStep.endX - currentPathStep.startX) * easeOutProgress;
                    token.currentY = currentPathStep.startY + (currentPathStep.endY - currentPathStep.startY) * easeOutProgress;
                } else {
                    token.currentX = currentPathStep.endX;
                    token.currentY = currentPathStep.endY;
                    pathIndex++;

                    if (pathIndex >= path.length) {
                        token.isMoving = false;
                        this.game.isAnimating = false;
                        callback();
                        return;
                    }

                    currentPathStep = path[pathIndex];
                    startTime = timestamp; 
                    this.game.sm.play('MOVE'); 
                }

                this.render();
                requestAnimationFrame(step);
            };

            this.game.isAnimating = true;
            requestAnimationFrame(step);
        }

        // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ© Ù„Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
        getAnimationPath(playerId, startPos, targetPos) {
            const path = [];
            let currentPos = startPos;

            while (currentPos !== targetPos) {
                let nextPos = currentPos + 1;

                if (currentPos < 4 && nextPos === 4) { 
                    nextPos = 4;
                }

                if (currentPos < 56 && nextPos > 55) { 
                    nextPos = 56;
                }

                if (currentPos >= 62) break;

                const tokenAtCurrent = new Token(0, playerId);
                tokenAtCurrent.position = currentPos;
                const startCoords = tokenAtCurrent.getCoords();

                const tokenAtNext = new Token(0, playerId);
                tokenAtNext.position = nextPos;
                const endCoords = tokenAtNext.getCoords();

                path.push({
                    startX: startCoords.x,
                    startY: startCoords.y,
                    endX: endCoords.x,
                    endY: endCoords.y,
                });

                currentPos = nextPos;
            }
            return path;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©
        handleClick(x, y) {
            if (this.game.isRolling || this.game.isAnimating || this.game.winner || this.game.isAIPlayer(this.game.currentPlayerIdx) || this.game.diceValue === 0) return;

            for (const player of this.game.players) {
                for (const token of player.tokens) {
                    const { x: tx, y: ty } = token.getCoords();
                    const distSq = (x - tx) ** 2 + (y - ty) ** 2;

                    if (distSq < this.tokenRadius ** 2 * 1.5) { // Ø²ÙŠØ§Ø¯Ø© Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù†Ù‚Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹
                        this.game.selectToken(token);
                        return;
                    }
                }
            }
        }

        handleCanvasClick(event) {
            const rect = CANVAS.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            this.handleClick(x, y);
        }
    }


    //================================================================================
    // 6. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    //================================================================================

    let game = new LudoGame();
    let renderer = new Renderer(game);
    game.renderer = renderer;

    const playerCountSelect = document.getElementById('player-count');
    const playerConfigDiv = document.getElementById('player-config');

    function updatePlayerConfig() {
        const count = parseInt(playerCountSelect.value);
        playerConfigDiv.innerHTML = '<p style="font-weight: bold; margin-bottom: 10px;">Ù†ÙˆØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†:</p>';

        for (let i = 0; i < 4; i++) {
            const colorName = PLAYER_COLORS[i].name;
            const colorCode = PLAYER_COLORS[i].color;
            const isVisible = i < count;

            const row = document.createElement('div');
            row.className = 'player-setup-row';
            row.style.display = isVisible ? 'flex' : 'none';

            // Ù…Ø¤Ø´Ø± Ø§Ù„Ù„ÙˆÙ†
            const colorIndicator = document.createElement('div');
            colorIndicator.className = 'color-indicator';
            colorIndicator.style.backgroundColor = colorCode;

            // Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
            const label = document.createElement('label');
            label.textContent = colorName;

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹ (Ø¨Ø´Ø±ÙŠ/Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ)
            const typeSelect = document.createElement('select');
            typeSelect.id = `player-type-${i}`;
            typeSelect.innerHTML = `<option value="HUMAN">${ARABIC_TEXT.HUMAN}</option><option value="AI">${ARABIC_TEXT.AI}</option>`;
            typeSelect.value = i === 0 ? 'HUMAN' : 'AI';

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (ÙŠØ¸Ù‡Ø± ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† AI)
            const levelSelect = document.createElement('select');
            levelSelect.id = `ai-level-${i}`;
            levelSelect.innerHTML = `<option value="EASY">${ARABIC_TEXT.EASY}</option><option value="MEDIUM" selected>${ARABIC_TEXT.MEDIUM}</option><option value="HARD">${ARABIC_TEXT.HARD}</option>`;
            levelSelect.style.display = typeSelect.value === 'AI' ? 'block' : 'none';

            typeSelect.addEventListener('change', () => {
                levelSelect.style.display = typeSelect.value === 'AI' ? 'block' : 'none';
            });

            row.appendChild(colorIndicator);
            row.appendChild(label);
            row.appendChild(typeSelect);
            row.appendChild(levelSelect);
            playerConfigDiv.appendChild(row);
        }
    }

    playerCountSelect.addEventListener('change', updatePlayerConfig);

    window.onload = function() {
        updatePlayerConfig();

        if (localStorage.getItem('ludoState')) {
            document.getElementById('resume-game').style.display = 'inline-block';
            document.getElementById('start-new-game').textContent = ARABIC_TEXT.START_NEW;
        } else {
             document.getElementById('resume-game').style.display = 'none';
             document.getElementById('start-new-game').textContent = ARABIC_TEXT.START_NEW;
        }

        renderer.render();
    }

    // ÙˆØ¸ÙŠÙØ© Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø© (Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£Ùˆ Ø§Ù„ÙÙˆØ²)
    function startNewGame(resume = false) {
        document.getElementById('setup-modal').classList.remove('active');
        document.getElementById('win-modal').classList.remove('active');

        if (resume) {
            try {
                const state = JSON.parse(localStorage.getItem('ludoState'));
                if (state) {
                    const playerConfigs = state.players.map(p => ({
                        type: p.type,
                        aiLevel: p.aiLevel
                    }));
                    game.setupGame(playerConfigs); 
                    game.loadGame(state); 
                    renderer.render();
                    renderer.updateCurrentPlayerIndicator(game.currentPlayerIdx); // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¤Ø´Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
                    return;
                }
            } catch(e) {
                console.error("Failed to load game state:", e);
                localStorage.removeItem('ludoState');
            }
        }

        // Ø¨Ø¯Ø¡ Ø¬Ø¯ÙŠØ¯
        const count = parseInt(playerCountSelect.value);
        const playerConfigs = [];
        for (let i = 0; i < count; i++) {
            const type = document.getElementById(`player-type-${i}`).value;
            const level = document.getElementById(`ai-level-${i}`).value;
            playerConfigs.push({ type, aiLevel: level });
        }

        game.setupGame(playerConfigs);
        renderer.updateCurrentPlayerIndicator(game.currentPlayerIdx); // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¤Ø´Ø± Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
    }

    // Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    document.getElementById('start-new-game').addEventListener('click', () => startNewGame(false));
    document.getElementById('resume-game').addEventListener('click', () => startNewGame(true));
    document.getElementById('setting-button').addEventListener('click', () => {
        document.getElementById('setup-modal').classList.add('active');
    });
    document.getElementById('mute-button').addEventListener('click', () => game.sm.toggleMute());
    document.getElementById('new-game-from-win').addEventListener('click', () => {
        document.getElementById('win-modal').classList.remove('active');
        document.getElementById('setup-modal').classList.add('active');
    });
    document.getElementById('share-screenshot').addEventListener('click', () => {
        const dataURL = CANVAS.toDataURL('image/png');
        const w = window.open('about:blank', '_blank');
        w.document.write('<img src="' + dataURL + '" style="max-width:100%; height:auto;">');
    });

</script>
</body>
</html>
